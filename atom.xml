<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://MOMENTUMxx.github.io</id>
    <title>王璐杰的BLOG</title>
    <updated>2020-10-10T12:08:41.289Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://MOMENTUMxx.github.io"/>
    <link rel="self" href="https://MOMENTUMxx.github.io/atom.xml"/>
    <subtitle>行百里者半九十</subtitle>
    <logo>https://MOMENTUMxx.github.io/images/avatar.png</logo>
    <icon>https://MOMENTUMxx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 王璐杰的BLOG</rights>
    <entry>
        <title type="html"><![CDATA[OutOfMemoryError异常--Java堆溢出]]></title>
        <id>https://MOMENTUMxx.github.io/post/outofmemoryerror-yi-chang-java-dui-yi-chu/</id>
        <link href="https://MOMENTUMxx.github.io/post/outofmemoryerror-yi-chang-java-dui-yi-chu/">
        </link>
        <updated>2020-10-10T11:40:52.000Z</updated>
        <summary type="html"><![CDATA[<p>在Java虚拟机规范的描述中，除了<strong>程序计数器</strong>外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(下文简称OOM)异常的可能，本文简单介绍一下会导致OOM异常出现的几种场景。🍓</p>
]]></summary>
        <content type="html"><![CDATA[<p>在Java虚拟机规范的描述中，除了<strong>程序计数器</strong>外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(下文简称OOM)异常的可能，本文简单介绍一下会导致OOM异常出现的几种场景。🍓</p>
<!-- more -->
<h1 id="java堆溢出">Java堆溢出</h1>
<p>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。<br>
下面的代码限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的<strong>内存堆转储快照</strong>以便事后进行分析。</p>
<pre><code class="language-java">public class HeapOOM {
    static class OOMObject{}
    public static void main(String[] args) {
        List&lt;OOMObject&gt; list = new ArrayList&lt;HeapOOM.OOMObject&gt;();
        while(true) {
            list.add(new OOMObject());
        }
    }
}
</code></pre>
<p>运行结果：<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602330641069.png" alt="" loading="lazy"><br>
Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。<br>
要解决这个区域的异常，一般的手段是先通过<strong>内存映像分析工具</strong>（如Eclipse Memory Analyzer）对Dump出来的<strong>堆转储快照</strong>进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清除到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。下图显示了使用Eclipse Memory Analyzer打开的堆转储快照文件。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602330757091.png" alt="" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">堆</mi><mi mathvariant="normal">转</mi><mi mathvariant="normal">储</mi><mi mathvariant="normal">快</mi><mi mathvariant="normal">照</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi></mrow><annotation encoding="application/x-tex">堆转储快照文件
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">堆</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">储</span><span class="mord cjk_fallback">快</span><span class="mord cjk_fallback">照</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span></span></span></span></span></p>
<p>解决方案：<br>
如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的<strong>引用链</strong>。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收他们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确的定位出泄漏代码的位置。<br>
如果不存在泄漏，换句话说，就是内存中的对象确实还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL基础学习笔记]]></title>
        <id>https://MOMENTUMxx.github.io/post/mysql-ji-chu/</id>
        <link href="https://MOMENTUMxx.github.io/post/mysql-ji-chu/">
        </link>
        <updated>2020-10-10T09:49:14.000Z</updated>
        <summary type="html"><![CDATA[<p>整理了一下之前的MySQL笔记，方便随时查漏补缺🍉</p>
]]></summary>
        <content type="html"><![CDATA[<p>整理了一下之前的MySQL笔记，方便随时查漏补缺🍉</p>
<!-- more -->
<h2 id="数据库相关概念">数据库相关概念★</h2>
<ol>
<li>DB： 数据库，保存一组有组织的数据的容器</li>
<li>DBMS：数据库管理系统，用于管理DB中的数据</li>
<li>SQL：结构化查询语言，用于和DBMS通信</li>
</ol>
<h2 id="数据库存储数据的特点">数据库存储数据的特点</h2>
<ol>
<li>将数据放到表中，表再放到库中</li>
<li>一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。</li>
<li>表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。</li>
<li>表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”</li>
<li>表中的数据是按行存储的，每一行类似于java中的“对象”。</li>
</ol>
<h2 id="mysql打开方式">MySQL打开方式</h2>
<ul>
<li>启动：net start mysql</li>
<li>关闭：net stop mysql</li>
</ul>
<h2 id="mysql服务的登录和退出">MySQL服务的登录和退出</h2>
<ul>
<li>通过windows自带的客户端（管理员下的命令行）
<ul>
<li>登录：
<ul>
<li>mysql 【-h 主机名 -P 端口号】 -u 用户名 -p密码</li>
</ul>
</li>
<li>退出：
<ul>
<li>exit或ctrl+c</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="mysql的常见命令">MySQL的常见命令</h2>
<ol>
<li>
<p>查看当前所有的数据库</p>
<p><code>show databases;</code></p>
</li>
<li>
<p>打开指定的库</p>
<p><code>use 库名</code></p>
</li>
<li>
<p>查看当前库的所有表</p>
<p><code>show tables</code></p>
</li>
<li>
<p>查看其他库的所有表</p>
<p><code>show tables from 库名</code></p>
</li>
<li>
<p>创建表</p>
<pre><code class="language-mySQL">create tabel 表名(
	列名 列类型，
 列名 列类型，
    。。。
)
</code></pre>
</li>
<li>
<p>查看表结构</p>
<p><code>desc 表名；</code></p>
</li>
<li>
<p>查看服务器的版本</p>
<p><code>方式一：登录到mysql服务端</code></p>
<p><code>select version();</code></p>
<p><code>方式二：没有登录到mysql服务端</code></p>
<p><code>mysql --version</code></p>
<p><code>或</code></p>
<p><code>mysql --V</code></p>
</li>
</ol>
<h2 id="mysql的语法规范">MySQL的语法规范</h2>
<ol>
<li>
<p>不区分大小写</p>
</li>
<li>
<p>每条命令最好用分号结尾</p>
</li>
<li>
<p>每条命令可以根据需要进行缩进 或换行</p>
</li>
<li>
<p>注释</p>
<p>单行注释：#注释文字</p>
</li>
</ol>
<h2 id="sql的语言分类">SQL的语言分类</h2>
<ul>
<li>DQL（Data Query Language）：数据查询语言
<ul>
<li>select</li>
</ul>
</li>
<li>DML(Data Manipulate Language):数据操作语言
<ul>
<li>insert 、update、delete</li>
</ul>
</li>
<li>DDL（Data Define Languge）：数据定义语言
<ul>
<li>create、drop、alter</li>
</ul>
</li>
<li>TCL（Transaction Control Language）：事务控制语言
<ul>
<li>commit、rollback</li>
</ul>
</li>
</ul>
<h2 id="dql语言">DQL语言</h2>
<h3 id="基础查询">基础查询</h3>
<ul>
<li>语法：select 查询列表 from 表名；</li>
<li>特点：
<ul>
<li>查询列表可以是：表中的字段、常量值、表达式、函数</li>
<li>通过select查询完的结果 ，是一个虚拟的表格，不是真实存在</li>
</ul>
</li>
</ul>
<ol>
<li>查询多个字段时用逗号隔开，最后一个字段不加逗号，语句的最后才加分号</li>
<li>起别名用AS，去重用DISTINCT，拼接用CONCAT(null和任意字符串拼接都为null)</li>
<li>+号的作用：
<ul>
<li>仅有一个功能：运算符</li>
<li>如果两个操作数都为数值型，则做加法运算</li>
<li>只要其中一方为字符型，试图将字符型数值转换成数值型
<ul>
<li>如果转换成功，则继续做加法运算</li>
<li>如果转换失败，则将字符型数值转换成0</li>
</ul>
</li>
<li>只要其中一方为null，则结果肯定为null</li>
</ul>
</li>
</ol>
<h3 id="条件查询">条件查询</h3>
<ul>
<li>语法：select 查询列表 from 表名 where 筛选条件；（执行顺序231）</li>
<li>模糊查询：like（可用通配符：%任意多个字符，包含0个；_任意单个字符），between and（含边界，顺序不能换），in（列表中的值必须一致或兼容），is (not)null</li>
</ul>
<h3 id="排序查询">排序查询</h3>
<ul>
<li>语法：select 要查询的东西 from 表 where 条件 order by 排序的字段|表达式|函数|别名【asc|desc】</li>
<li>特点：默认升序，order by一般放在查询语句的最后(limit语句除外)</li>
</ul>
<h3 id="常见函数">常见函数</h3>
<h4 id="一-单行函数">一、单行函数</h4>
<h5 id="1-字符函数">1、字符函数</h5>
<p>concat,substr,upper,lower,trim,ltrim,rtrim,,replace,lpad,rpad,instr,length(获取字节个数)</p>
<h5 id="2-数学函数">2、数学函数</h5>
<p>round,rand,floor,ceil,mod,truncate(截断)</p>
<h5 id="3-日期函数">3、日期函数</h5>
<p>now,curdate,curtime,str_to_date(将字符转换成日期),date_format(将日期转换成字符)，datediff(返回两个日期相差的天数),monthname(以英文形式返回月)</p>
<h5 id="4-流程控制函数">4、流程控制函数</h5>
<ol>
<li>
<p>if(条件表达式，表达式1，表达式2)</p>
</li>
<li>
<p>case</p>
<ol>
<li>
<pre><code class="language-mySQL">case 变量或表达式或字段
      when 常量1 then 值1
      when 常量2 then 值2
       ...
      else 值a
  end
</code></pre>
</li>
<li>
<pre><code class="language-mySQL">case
      when 条件1 then 值1
      when 条件2 then 值2
        ...
      else 值a
  end
</code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="二-分组函数">二、分组函数</h4>
<p>sum,max,min,avg,count</p>
<ul>
<li>特点：
<ol>
<li>以上五个分组函数都忽略null值，除了count(*)</li>
<li>sum和avg一般用于处理数值型，max、min、count可以处理任何数据类型</li>
<li>都可以搭配distinct使用，用于统计去重后的结果</li>
<li>count(字段):统计该字段非空值的个数；通常用count(*)来计数</li>
<li>和分组函数一同查询的字段必须是分组后的（group by后）</li>
</ol>
</li>
</ul>
<h3 id="分组查询">分组查询</h3>
<ul>
<li>
<p>语法：select 分组函数，分组的字段 from 表 【where 筛选条件】 group by 分组的字段 【having 分组后的筛选】 【order by 排序列表】</p>
</li>
<li>
<p>特点：</p>
<ol>
<li>
<p>分组筛选</p>
<table>
<thead>
<tr>
<th></th>
<th>针对的表</th>
<th>位置</th>
<th style="text-align:center">关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>分组前筛选</td>
<td>原始表</td>
<td>group by的前面</td>
<td style="text-align:center">where</td>
</tr>
<tr>
<td>分组后筛选</td>
<td>分组后的结果集</td>
<td>group by的后面</td>
<td style="text-align:center">having</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>可以按多个字段分组，字段之间用逗号隔开</p>
</li>
<li>
<p>可以支持排序</p>
</li>
<li>
<p>having后可以支持别名</p>
</li>
</ol>
</li>
</ul>
<h3 id="多表连接查询">多表连接查询</h3>
<h4 id="一-含义">一、含义</h4>
<p>​	当查询中涉及到了多个表的字段，需要使用多表连接。</p>
<p>​	<code>select 字段1，字段2</code></p>
<p>​	<code>from 表1，表2...;</code></p>
<h4 id="二-分类">二、分类：</h4>
<ol>
<li>
<p>sql92</p>
<p>等值连接，非等值连接，自连接</p>
</li>
<li>
<p>sql99</p>
<ul>
<li>
<p>内连接：等值，非等值，自连接</p>
</li>
<li>
<p>外连接：左外，右外，全外</p>
</li>
<li>
<p>交叉连接：</p>
</li>
</ul>
</li>
</ol>
<h4 id="三-sql92语法">三、SQL92语法</h4>
<ol>
<li>
<p>等值连接</p>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL"> select 查询列表
from 表1 别名，表2 别名
 where 表1.key=表2.key
【and 筛选条件】
 【group by 分组字段】
【having 分组后的字段】
 【order by 排序字段】
</code></pre>
</li>
<li>
<p>特点：</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>等值连接的结果等于多个表的交集
<ul>
<li>n表连接，至少需要n-1个连接条件</li>
</ul>
</li>
<li>多个表不分主次，没有顺序要求
<ul>
<li>一般为表起别名，起别名后所有位置的表名都要用别名</li>
</ul>
</li>
</ul>
<ol start="2">
<li>
<p>非等值连接</p>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">select 查询列表
from 表1 别名，表2 别名
where 非等值的连接条件
【and 筛选条件】
【group by 分组字段】
【having 分组后的字段】
【order by 排序字段】
</code></pre>
</li>
</ul>
</li>
<li>
<p>自连接</p>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">select 查询列表
from 表 别名1，表 别名2
where 等值的连接条件
【and 筛选条件】
【group by 分组字段】
【having 分组后的字段】
【order by 排序字段】
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="四-sql99语法">四、SQL99语法</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">	select 查询列表
	from 表1 别名 【连接类型】
	join 表2 别名 
	on 连接条件
	【where 筛选条件】
	【group by 分组】
	【having 筛选条件】
	【order by 排序列表】
</code></pre>
</li>
<li>
<p>分类</p>
<ul>
<li>内连接：inner</li>
<li>外连接
<ul>
<li>左外：left outer</li>
<li>右外：right outer</li>
<li>全外：full outer</li>
</ul>
</li>
<li>交叉连接（笛卡尔乘积）</li>
</ul>
</li>
</ul>
<h5 id="1内连接">1）内连接</h5>
<ul>
<li>
<p>语法</p>
<pre><code class="language-mySQL">select 查询列表
from 表1 别名
inner join 表2 别名
on 连接条件
where 筛选条件
group by 分组列表
having 分组后的筛选
order by 排序列表
limit 子句；
</code></pre>
</li>
<li>
<p>分类：等值，非等值，自连接</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>筛选条件放在where后面，连接条件放在on后面，提高分离性</li>
<li>表的顺序可以调换</li>
<li>内连接的结果=多表的交集</li>
<li>n表连接至少需要n-1个连接条件</li>
</ul>
</li>
</ul>
<h5 id="2外连接">2）外连接</h5>
<ul>
<li>
<p>应用场景：用于查询一个表中有，另一个表没有的记录</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">select 查询列表
from 表1 别名
left|right|full join 表2 别名
on 连接条件
where 筛选条件
group by 分组列表
having 分组后的筛选
order by 排序列表
limit 子句
</code></pre>
</li>
<li>
<p>特点：</p>
<ul>
<li>
<p>外连接查询结果=内连接结果+主表有而从表没有的记录</p>
<p>或者说，查询结果=主表中所有的行，如果从表有匹配的将显示匹配行，否则显示null</p>
</li>
<li>
<p>左外连接，left join左边的是主表；右外连接，right join右边的是主表</p>
</li>
<li>
<p>全外连接=内连接+表1中有但表2没有的+表2中有但表1没有的</p>
</li>
</ul>
</li>
<li>
<p>图解：</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://MOMENTUMxx.github.io/post-images/1602325044299.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://MOMENTUMxx.github.io/post-images/1602325053596.png" alt="" loading="lazy"></figure>
<h3 id="子查询">子查询</h3>
<ul>
<li>
<p>含义：出现在其他语句中的select语句称为子查询或内查询；</p>
<p>外部的查询语句（select较多），称为主查询或外查询</p>
</li>
<li>
<p>分类：</p>
<ul>
<li>按子查询出现的位置：
<ul>
<li>select后面：仅支持标量子查询</li>
<li>from后面：支持表子查询</li>
<li>where或having后面：一般用到标量子查询和列子查询</li>
<li>exists后面：表子查询</li>
</ul>
</li>
<li>按结果集的行列数不同：
<ul>
<li>标量子查询：一行一列</li>
<li>列子查询：一列多行</li>
<li>行子查询：一行多列</li>
<li>表子查询：一般多行多列</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="一-where或having后面">一、where或having后面</h4>
<ul>
<li>特点：
<ul>
<li>子查询放在小括号里</li>
<li>标量子查询一般搭配单行操作符使用：&gt; &lt; &gt;= &lt;=  = &lt;&gt;</li>
<li>列子查询一般搭配多行操作符使用：in any/some all</li>
<li>子查询的执行优先于主查询进行，主查询的条件用到了子查询的结果</li>
</ul>
</li>
</ul>
<h4 id="二-select后面">二、select后面</h4>
<ul>
<li>仅仅支持标量子查询</li>
</ul>
<h4 id="三-from后面">三、from后面</h4>
<ul>
<li>将子查询结果充当一张表，要求必须起别名</li>
</ul>
<h3 id="分页查询">分页查询</h3>
<ul>
<li>
<p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">select 查询列表
from 表
【join type join 表2
on 连接条件
where 筛选条件
group by 分组字段
having 分组后的筛选
order by 排序的字段】
limit 【offset,】size;
</code></pre>
<p>offset为要显示条目的起始索引（从0开始，默认为0）</p>
<p>size为要显示的条目个数</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>
<p>limit语句放在查询语句的最后</p>
</li>
<li>
<p>公式：</p>
<ul>
<li>
<p>要显示的页数 page，每页的条目数size</p>
<pre><code class="language-mySQL">select 查询列表
from 表
limit (page-1)*size,size;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="联合查询">联合查询</h3>
<ul>
<li>
<p>含义：将多条查询语句的结果合并成一个结果</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">查询语句1
union
查询语句2
union
...
</code></pre>
</li>
<li>
<p>应用场景：要查询的结果来自多个表，且多个表没有直接的连接关系，但查询的信息一致时</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>要求多条查询语句的查询列数是一致的</li>
<li>要求多条查询语句查询的每一列的类型和顺序最好一致</li>
<li>union关键字默认去重，如果使用union all可以包含重复项</li>
</ul>
</li>
</ul>
<h3 id="dql语言执行顺序总结">DQL语言执行顺序总结</h3>
<blockquote>
<pre><code class="language-mySQL">select 查询列表			7
from 表             	  1
连接类型 join 表2	   2 
on 连接条件				3
where 筛选条件          4
group by 分组列表       5
having 分组后的筛选      6
order by 排序列表       8
limit 起始索引，条目数   9	
</code></pre>
</blockquote>
<h2 id="dml语言">DML语言</h2>
<p>​		插入：insert</p>
<p>​		修改：update</p>
<p>​		删除：delete</p>
<h3 id="一-插入语句">一、插入语句</h3>
<h4 id="方式一经典的插入">方式一：经典的插入</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">insert into 表名(列名,...) values(值,...),values(值,...),...;
</code></pre>
</li>
<li>
<p>特点：</p>
<ul>
<li>插入的值的类型要与列的类型一致或兼容</li>
<li>不可以为null的列必须插入值，可以为null的列能够通过两种方式插入null值
<ul>
<li>字段和值都省略</li>
<li>写字段，值使用null</li>
</ul>
</li>
<li>列的顺序可以调换</li>
<li>列数和值的个数必须一致</li>
<li>可以省略列名，默认为所有列，而且的列的顺序和表中列的顺序一致</li>
</ul>
</li>
</ul>
<h4 id="方式二">方式二</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">insert into 表名
set 列名=值，列名=值...
</code></pre>
</li>
</ul>
<h4 id="两种方式的比较">两种方式的比较</h4>
<ol>
<li>
<p>方式一支持插入多行，方式二不支持</p>
</li>
<li>
<p>方式一支持子查询，方式二不支持</p>
<p>如：</p>
<pre><code class="language-mySQL">INSERT INTO beauty(id,NAME,phone)
SELECT id,boyname,'1234567'
FROM boys WHERE id&lt;3;
</code></pre>
</li>
</ol>
<h3 id="二-修改语句">二、修改语句</h3>
<h4 id="1-修改单表的记录">1. 修改单表的记录★</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">update 表名
set 列=新值，列=新值...
where 筛选条件；
</code></pre>
</li>
</ul>
<h4 id="2-修改多表的记录">2. 修改多表的记录</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">update 表1 别名
inner|left|right join 表2 别名
on 连接条件
set 列=值,...
where 筛选条件;
</code></pre>
</li>
</ul>
<h3 id="三-删除语句">三、删除语句</h3>
<h4 id="方式一delete">方式一：delete</h4>
<ul>
<li>
<p>语法：</p>
<ol>
<li>
<p>单表的删除★</p>
<pre><code class="language-mySQL">delete from 表名 where 筛选条件【limit 条目数】；
</code></pre>
</li>
<li>
<p>多表的删除</p>
<pre><code class="language-mySQL">delete 表1的别名,表2的别名
from 表1 别名
inner|left|right join 表2 别名
on 连接条件
where 筛选条件；
</code></pre>
</li>
</ol>
</li>
</ul>
<h4 id="方式二truncate">方式二：truncate</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">truncate table 表名；
</code></pre>
</li>
</ul>
<h4 id="delete和truncate比较">delete和truncate比较★</h4>
<ol>
<li>delete可以加筛选条件，truncate不能加</li>
<li>truncate效率略高一点</li>
<li>加入要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始</li>
<li>truncate删除没有返回值，delete删除有返回值</li>
<li>truncate删除不能回滚，delete删除可以回滚</li>
</ol>
<h2 id="ddl语言">DDL语言</h2>
<p>​		创建：create</p>
<p>​		修改：alter</p>
<p>​		删除：drop</p>
<h3 id="一-库的管理">一、库的管理</h3>
<h4 id="1-库的创建">1. 库的创建</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">create database 【if not exists】 库名;
</code></pre>
</li>
</ul>
<h4 id="2-库的修改">2. 库的修改</h4>
<ul>
<li>
<p>更改库的字符集</p>
<pre><code class="language-mySQL">alter database 库名 character set 字符集名;
</code></pre>
</li>
</ul>
<h4 id="3-库的删除">3. 库的删除</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">drop database if exists 库名;
</code></pre>
</li>
</ul>
<h3 id="二-表的管理">二、表的管理</h3>
<h4 id="1-表的创建">1. 表的创建★</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">create table 表名(
	列名 列的类型【(长度) 约束】,
	列名 列的类型【(长度) 约束】,
	列名 列的类型【(长度) 约束】,
	...
	列名 列的类型【(长度) 约束】
)
</code></pre>
</li>
</ul>
<h4 id="2-表的修改">2. 表的修改</h4>
<ol>
<li>
<p>添加列：</p>
<pre><code class="language-mySQL">alter table 表名 add column 列名 类型 【first|alter 字段名】;
</code></pre>
</li>
<li>
<p>修改列的类型或约束</p>
<pre><code class="language-mySQL">alter table 表名 modify column 列名 新类型 【新约束】;
</code></pre>
</li>
<li>
<p>修改列名</p>
<pre><code class="language-mySQL">alter table 表名 change column 旧列名 新列名 类型;
</code></pre>
</li>
<li>
<p>删除列</p>
<pre><code class="language-mySQL">alter table 表名 drop column 列名;
</code></pre>
</li>
<li>
<p>修改表名</p>
<pre><code class="language-mySQL">alter table 表名 rename 【to】 新表名;
</code></pre>
</li>
</ol>
<h4 id="3-表的删除">3. 表的删除</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">drop table 【if exists】 表名;
</code></pre>
</li>
</ul>
<h4 id="4-表的复制">4. 表的复制</h4>
<ol>
<li>
<p>仅仅复制表的结构</p>
<pre><code class="language-mySQL">create table 新表 like 旧表;
</code></pre>
</li>
<li>
<p>复制表的结构+数据</p>
<ul>
<li>
<p>全部数据</p>
<pre><code class="language-mySQL">create table 新表
select * from 旧表;
</code></pre>
</li>
<li>
<p>部分数据</p>
<pre><code class="language-mySQL">create table 新表
select 字段1,字段2... 
from 旧表
where 筛选条件;
</code></pre>
</li>
<li>
<p>仅仅复制某些字段</p>
<pre><code class="language-mySQL">create table 新表
select 字段1,字段2... 
from 旧表
where 0; 
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="常见的数据类型">常见的数据类型</h3>
<h4 id="一-数值型">一、数值型</h4>
<ol>
<li>整形</li>
</ol>
<ul>
<li>
<p>分类：tinyint(1),smallint(2),mediumint(3),int/integer(4),bigint(8)</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>如果不设置无符号还是有符号，默认是有符号，设置无符号要添加关键字unsigned</li>
<li>如果插入的数值超出了整型的范围，会报out of range异常，并且插入临界值</li>
<li>如果不设置长度，会有默认的长度（长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用）</li>
</ul>
</li>
</ul>
<ol start="2">
<li>浮点型</li>
</ol>
<ul>
<li>
<p>分类：</p>
<ul>
<li>浮点型：float(M,D),double(M,D)</li>
<li>定点型：decimal(M,D)</li>
</ul>
</li>
<li>
<p>特点：</p>
<ul>
<li>
<p>M：整数部位+小数部位的个数</p>
<p>D：小数部位的个数</p>
<p>如果超过范围，则插入临界值</p>
</li>
<li>
<p>M和D都可以省略</p>
<p>如果是decimal，则M默认为10，D默认为0</p>
<p>如果是float和double，则会根据插入的数值的精度来决定精度</p>
</li>
<li>
<p>定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</p>
</li>
</ul>
</li>
<li>
<p>原则：</p>
<p>所选择的类型越简单越好，能保存数值的类型越小越好</p>
</li>
</ul>
<h4 id="二-字符型">二、字符型</h4>
<ul>
<li>
<p>较短的文本：char和varchar</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th>写法</th>
<th>M的意思</th>
<th>特点</th>
<th>空间的耗费</th>
<th>效率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">char</td>
<td>char(M)</td>
<td>最大的字符数</td>
<td>可以省略，默认为1，长度固定</td>
<td>比较耗费</td>
<td>高</td>
</tr>
<tr>
<td style="text-align:center">varchar</td>
<td>varchar(M)</td>
<td>最大的字符数</td>
<td>不可以省略，长度可变</td>
<td>比较节省</td>
<td>低</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>较长的文本：text，blob（较大的二进制）</p>
</li>
<li>
<p>其他：binary和varbinary用于保存较短的二进制</p>
<p>​			enum用于保存枚举</p>
<p>​			set用于保存集合</p>
</li>
</ul>
<h4 id="三-日期型">三、日期型</h4>
<ul>
<li>
<p>分类：date,time,year,datetime,timestamp</p>
</li>
<li>
<p>特点：</p>
<table>
<thead>
<tr>
<th></th>
<th>字节</th>
<th>范围</th>
<th style="text-align:center">时区等的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>datetime</td>
<td>8</td>
<td>1000-9999</td>
<td style="text-align:center">不受</td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>1970-2038</td>
<td style="text-align:center">受</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="常见约束">常见约束</h3>
<ul>
<li>含义：一种限制，用于限制表中的数据，为了保证表中数据的准确和可靠性</li>
<li>分类：六大约束
<ul>
<li>NOT NULL:非空，用于保证该字段的值不能为空</li>
<li>DEFAULT:默认，用于保证该字段有默认值</li>
<li>PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空</li>
<li>UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为null</li>
<li>CHECK:检查约束【mysql不支持】</li>
<li>FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自主表的关联列的值。在从表添加外键约束，用于引用主表中某列的值</li>
</ul>
</li>
<li>添加约束的时机：
<ol>
<li>创建表时</li>
<li>修改表时</li>
</ol>
</li>
<li>约束的添加分类：
<ul>
<li>列级约束：六大约束语法上都支持，但外键约束没有效果</li>
<li>表级约束：除了NOT NULL和DEFAULT其他都支持</li>
</ul>
</li>
</ul>
<h4 id="一-创建表时添加约束">一、创建表时添加约束</h4>
<ol>
<li>添加列级约束</li>
</ol>
<ul>
<li>语法:直接在字段名和类型后面追加约束类型即可，只支持：默认、非空、主键、唯一
<ul>
<li>列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求</li>
</ul>
</li>
</ul>
<ol start="2">
<li>
<p>添加表级约束</p>
<ul>
<li>
<p>语法：在各个字段的最下面</p>
<p>【constraint 约束名】 约束类型(字段名)</p>
</li>
</ul>
</li>
<li>
<p>通用写法示例</p>
<pre><code class="language-mySQL">CREATE TABLE stuinfo(
	字段名 字段类型 PRIMARY KEY,
	字段名 字段类型 NOT NULL,
	字段名 字段类型 UNIQUE,
	字段名 字段类型 DEFAULT 值,
	CONSTRAINT 约束名 FOREIGN KEY(字段名) REFERENCES 主表(被引用列)
);
</code></pre>
</li>
</ol>
<ul>
<li>
<p>主键和唯一的比较</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">保证唯一性</th>
<th style="text-align:center">是否允许为空</th>
<th style="text-align:center">一个表中可以有多少个</th>
<th style="text-align:center">是否允许组合</th>
</tr>
</thead>
<tbody>
<tr>
<td>主键</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">至多有一个</td>
<td style="text-align:center">√（不推荐）</td>
</tr>
<tr>
<td>唯一</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">可以有多个</td>
<td style="text-align:center">√（不推荐）</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>外键：</p>
<ul>
<li>
<p>要求在从表设置外键关系</p>
</li>
<li>
<p>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</p>
</li>
<li>
<p>主表的关联列必须是一个key（一般是主键或唯一）</p>
</li>
<li>
<p>插入数据时，先插入主表，再插入从表；</p>
<p>删除数据时，先删除从表，在删除主表</p>
</li>
<li>
<p>级联删除：设置外键时追加ON DELETE CASCADE</p>
<p>级联置空：设置外键时追加ON DELETE SET NULL</p>
<p>这两种删除方式不受上一点的约束</p>
</li>
</ul>
</li>
</ul>
<h4 id="二-修改表时添加删除约束">二、修改表时添加/删除约束</h4>
<ol>
<li>
<p>非空</p>
<ul>
<li>
<p>添加非空</p>
<pre><code class="language-mySQL">alter table 表名 modify column 字段名 字段类型 not null;
</code></pre>
</li>
<li>
<p>删除非空</p>
<pre><code class="language-mySQL">alter table 表名 modify column 字段名 字段类型;
</code></pre>
</li>
</ul>
</li>
<li>
<p>默认</p>
<ul>
<li>
<p>添加默认</p>
<pre><code class="language-mySQL">alter table 表名 modify column 字段名 字段类型 default 值;
</code></pre>
</li>
<li>
<p>删除默认</p>
<pre><code class="language-mySQL">alter table 表名 modify column 字段名 字段类型;
</code></pre>
</li>
</ul>
</li>
<li>
<p>主键</p>
<ul>
<li>
<p>添加主键</p>
<pre><code class="language-mySQL">alter table 表名 add【constraint 约束名】primary key(字段名);
</code></pre>
</li>
<li>
<p>删除主键</p>
<pre><code class="language-mySQL">alter table 表名 drop primary key;
</code></pre>
</li>
</ul>
</li>
<li>
<p>唯一</p>
<ul>
<li>
<p>添加唯一</p>
<pre><code class="language-mySQL">alter table 表名 add【constraint 约束名】unique(字段名);
</code></pre>
</li>
<li>
<p>删除唯一</p>
<pre><code class="language-mySQL">alter table 表名 drop index 索引名;
</code></pre>
</li>
</ul>
</li>
<li>
<p>外键</p>
<ul>
<li>
<p>添加外键</p>
<pre><code class="language-mySQL">alter table 表名 add【constraint 约束名】foreign key(字段名) references 主表(被引用列);
</code></pre>
</li>
<li>
<p>删除外键</p>
<pre><code class="language-mySQL">alter table 表名 drop foreign key 约束名;
</code></pre>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>列级约束和表级约束比较</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">位置</th>
<th style="text-align:center">支持的约束类型</th>
<th style="text-align:center">是否可以起约束名</th>
</tr>
</thead>
<tbody>
<tr>
<td>列级约束</td>
<td style="text-align:center">列的后面</td>
<td style="text-align:center">语法都支持，但外键没有效果</td>
<td style="text-align:center">不可以</td>
</tr>
<tr>
<td>表级约束</td>
<td style="text-align:center">所有列的下面</td>
<td style="text-align:center">默认和非空不支持，其他支持</td>
<td style="text-align:center">可以（主键没有效果）</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="标识列自增长列">标识列（自增长列）</h3>
<ul>
<li>含义：可以不用手动的插入值，系统提供默认的序列</li>
<li>特点：
<ul>
<li>默认从1开始，步长为1</li>
<li>标识列必须和一个key（主键，唯一，外键）搭配</li>
<li>一个表中至多有一个标识列</li>
<li>标识列的类型只能是数值型</li>
</ul>
</li>
</ul>
<h4 id="一-创建表时设置标识列">一、创建表时设置标识列</h4>
<pre><code class="language-mySQL">create table 表名(
	字段名 字段类型 约束条件 AUTO_INCREMENT,
	...
);
</code></pre>
<h4 id="二-修改表时设置标识列">二、修改表时设置标识列</h4>
<pre><code class="language-mySQL">alter table 表名 modify column 字段名 字段类型 约束条件 AUTO_INCREMENT;
</code></pre>
<h4 id="三-修改表时删除标识列">三、修改表时删除标识列</h4>
<pre><code class="language-mySQL">alter table 表名 modify column 字段名 字段类型 约束条件;
</code></pre>
<h2 id="tcl语言">TCL语言</h2>
<h3 id="事务">事务</h3>
<p>​		事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事务开始以前的状态；如果单元中的所有SQL语句均执行成功，则事务被顺利执行。</p>
<h4 id="事务的acid属性">事务的ACID属性</h4>
<ol>
<li>原子性(Atomicity):事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</li>
<li>一致性(Consistency):事务必须使数据库从一个一致性状态变换到另一个一致性状态</li>
<li>隔离性(Isolation):一个事务的执行不能被其他事务干扰</li>
<li>持久性(Durability):一个事务一旦被提交，它对数据库中数据的改变就是永久性的</li>
</ol>
<h4 id="事务的创建">事务的创建★</h4>
<ul>
<li>
<p>隐式事务：事务没有明显的开启和结束的标记；比如insert,update,delete</p>
</li>
<li>
<p>显式事务：事务具有明显的开启和结束的标记；前提：必须先设置自动提交功能为禁用</p>
<ul>
<li>
<p>步骤1：开启事务</p>
<pre><code class="language-mySQL">set autocommit=0;
start transaction;（可选的）
</code></pre>
</li>
<li>
<p>步骤2：编写事务中的sql语句(select,insert,update,delete)</p>
<pre><code class="language-mySQL">语句1，
语句2，
savepoint 节点名;（设置保存点）
......
</code></pre>
</li>
<li>
<p>步骤3：结束事务</p>
<pre><code class="language-mySQL">commit;（提交事务）
rollback;（回滚事务）
rollback to 回滚点名;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="并发事务">并发事务</h4>
<ol>
<li>
<p>事务的并发问题是如何发生的？</p>
<p>多个事务同时操作同一个数据库的相同数据</p>
</li>
<li>
<p>并发问题有哪些？</p>
<ul>
<li>脏读：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据</li>
<li>不可重复读：一个事务多次读取，结果不一样</li>
<li>幻读：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“插入”的数据</li>
</ul>
</li>
<li>
<p>如何解决并发问题？</p>
<p>设置隔离级别</p>
</li>
</ol>
<h4 id="事务的隔离级别">事务的隔离级别</h4>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>read uncommitted（读未提交）</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>read committed（读已提交）</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>repeatable read（可重复读）</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>serializable（串行化）</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>mysql中默认隔离级别是repeatable read</p>
</li>
<li>
<p>查看隔离级别的命令：</p>
<pre><code class="language-mySQL">select @@tx_isolation;
</code></pre>
</li>
<li>
<p>设置隔离级别的命令：</p>
<pre><code class="language-mySQL">set session|global transaction isolation level 隔离级别;
</code></pre>
</li>
</ul>
<h3 id="视图">视图</h3>
<ul>
<li>含义：虚拟表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。</li>
<li>应用场景：多个地方用到同样的查询结果，该查询结果使用的sql语句较复杂</li>
<li>好处：
<ul>
<li>简化sql语句</li>
<li>提高了sql的重用性</li>
<li>保护基表的数据，提高了安全性</li>
</ul>
</li>
</ul>
<h4 id="一-创建视图">一、创建视图</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">create view 视图名
as
查询语句;
</code></pre>
</li>
</ul>
<h4 id="二-视图的修改">二、视图的修改</h4>
<ul>
<li>
<p>方式一：</p>
<pre><code class="language-mySQL">create or replace view 视图名
as
查询语句;
</code></pre>
</li>
<li>
<p>方式二：</p>
<pre><code class="language-mySQL">alter view 视图名
as
查询语句;
</code></pre>
</li>
</ul>
<h4 id="三-删除视图">三、删除视图</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">drop view 视图名,视图名,...;
</code></pre>
</li>
</ul>
<h4 id="四-查看视图">四、查看视图</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">desc 视图名;
或
show create view 视图名;
</code></pre>
</li>
</ul>
<h4 id="五-视图的更新">五、视图的更新</h4>
<p>与表类似，<strong>但视图一般用于查询</strong>，而不是更新，所以具备以下特点的视图都不允许更新：</p>
<ol>
<li>包含分组函数、group by、distinct、having、union</li>
<li>join</li>
<li>常量视图</li>
<li>where后的子查询用到了from中的表</li>
<li>用到了不可更新的视图</li>
</ol>
<h4 id="六-视图和表的对比">六、视图和表的对比</h4>
<table>
<thead>
<tr>
<th></th>
<th>创建语法的关键字</th>
<th>保存的内容</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>视图</td>
<td>create view</td>
<td>sql逻辑</td>
<td>增删改查（一般只查）</td>
</tr>
<tr>
<td>表</td>
<td>create table</td>
<td>实际数据</td>
<td>增删改查</td>
</tr>
</tbody>
</table>
<h2 id="变量">变量</h2>
<ul>
<li>系统变量
<ul>
<li>全局变量</li>
<li>会话变量</li>
</ul>
</li>
<li>自定义变量
<ul>
<li>用户变量</li>
<li>局部变量</li>
</ul>
</li>
</ul>
<h3 id="一-系统变量">一、系统变量</h3>
<ul>
<li>
<p>说明：变量由系统提供，不是用户定义，属于服务器层面</p>
</li>
<li>
<p>语法：</p>
<ol>
<li>
<p>查看所有的系统变量</p>
<pre><code class="language-mySQL">show global|【session】 variables;
</code></pre>
</li>
<li>
<p>查看满足条件的部分系统变量</p>
<pre><code class="language-mySQL">show global|【session】 variables like '%char%';
</code></pre>
</li>
<li>
<p>查看指定的某个系统变量的值</p>
<pre><code class="language-mySQL">select @@global|【session】.系统变量名;
</code></pre>
</li>
<li>
<p>为某个系统变量赋值</p>
<p>方式一：</p>
<pre><code class="language-mySQL">set global|【session】 系统变量名=值；
</code></pre>
<p>方式二：</p>
<pre><code class="language-mySQL">set @@global|【session】.系统变量名=值;
</code></pre>
</li>
</ol>
</li>
<li>
<p>注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认session</p>
</li>
</ul>
<h4 id="1-全局变量">1. 全局变量</h4>
<ul>
<li>作用域：服务器每次启动将为所有的全局变量赋初始值，针对于所有的会话（连接）有效，但不能跨重启</li>
</ul>
<h4 id="2-会话变量">2. 会话变量</h4>
<ul>
<li>作用域：仅仅针对当前会话（连接）有效，应用在任何地方，也就是begin end里面外面均可</li>
</ul>
<h3 id="二-自定义变量">二、自定义变量</h3>
<ul>
<li>说明：变量是用户自定义的，不是由系统提供</li>
<li>使用步骤：声明，赋值，使用（查看、比较、运算等）</li>
</ul>
<h4 id="1-用户变量">1. 用户变量</h4>
<ul>
<li>作用域：针对于当前会话（连接）有效</li>
<li>位置：可以放在begin end里面或外面</li>
</ul>
<ol>
<li>
<p>声明并初始化，赋值的操作符：=或:=</p>
<pre><code class="language-mySQL">set @用户变量名=值;
或
set @用户变量名:=值;
或
select @用户变量名:=值;
</code></pre>
</li>
<li>
<p>赋值（更新用户变量的值）</p>
<p>方式一：通过set或select</p>
<pre><code class="language-mySQL">set @用户变量名=值;
或
set @用户变量名:=值;
或
select @用户变量名:=值;
</code></pre>
<p>方式二：通过select into</p>
<pre><code class="language-mySQL">select 字段 into @变量名
from 表;
</code></pre>
</li>
<li>
<p>使用（查看）</p>
<pre><code class="language-mySQL">select @用户变量名;
</code></pre>
</li>
</ol>
<h4 id="2-局部变量">2. 局部变量</h4>
<ul>
<li>作用域：仅仅在定义它的begin end中有效，应用在begin end中的第一句话！！</li>
</ul>
<ol>
<li>
<p>声明</p>
<pre><code class="language-mySQL">declare 变量名 类型;
或
declare 变量名 类型 default 值;
</code></pre>
</li>
<li>
<p>赋值</p>
<p>方式一：通过set或select</p>
<pre><code class="language-mySQL">set 局部变量名=值;
或
set 局部变量名:=值;
或
select @局部变量名:=值;
</code></pre>
<p>方式二：通过select into</p>
<pre><code class="language-mySQL">select 字段 into 局部变量名
from 表;
</code></pre>
</li>
<li>
<p>使用</p>
<pre><code class="language-mySQL">select 局部变量名;
</code></pre>
</li>
</ol>
<h4 id="3-对比用户变量和局部变量">3. 对比用户变量和局部变量</h4>
<table>
<thead>
<tr>
<th></th>
<th>作用域</th>
<th>定义和使用的位置</th>
<th>语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户变量</td>
<td>当前会话</td>
<td>会话中的任何地方</td>
<td>必须加@，不用限定类型</td>
</tr>
<tr>
<td>局部变量</td>
<td>begin end中</td>
<td>只能在begin end中，且为第一句话</td>
<td>除select外一般不用加@，需要限定类型</td>
</tr>
</tbody>
</table>
<h2 id="存储过程和函数">存储过程和函数</h2>
<p>存储过程和函数的结尾可以使用delimiter重新设置</p>
<p>语法：</p>
<pre><code class="language-mySQL">demiliter 结束标记
</code></pre>
<p>设置完成后end后面和每次调用存储过程和函数的结尾都要加上结束标记</p>
<h3 id="存储过程">存储过程</h3>
<ul>
<li>含义：一组预先编译好的SQL语句的集合，理解成批处理语句</li>
<li>好处：
<ul>
<li>提高代码的重用性</li>
<li>简化操作</li>
<li>减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</li>
</ul>
</li>
</ul>
<h4 id="一-创建语法">一、创建语法★</h4>
<pre><code class="language-mySQL">create procedure 存储过程名(参数列表)
begin
	存储过程体（一组合法的SQL语句）
end
</code></pre>
<ul>
<li>
<p>注意</p>
<ol>
<li>
<p>参数列表包含三部分：参数模式，参数名，参数类型</p>
<p>参数模式：</p>
<p>IN：该参数可以作为输入，需要调用方传入值</p>
<p>OUT：该参数可以作为输出，也就是可以作为返回值</p>
<p>INOUT：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值</p>
</li>
<li>
<p>如果存储过程体只有一句话，begin end可以省略</p>
</li>
<li>
<p>存储过程体中的每条SQL语句的结尾要求必须加分号</p>
</li>
</ol>
</li>
</ul>
<h4 id="二-调用语法">二、调用语法</h4>
<ul>
<li>
<p>调用in模式的参数：</p>
<pre><code class="language-mySQL">call 存储过程名('值');
</code></pre>
</li>
<li>
<p>调用out模式的参数：</p>
<pre><code class="language-mySQL">set @变量名;
call 存储过程名(@变量名);
select @变量名;
</code></pre>
</li>
<li>
<p>调用inout模式的参数：</p>
<pre><code class="language-mySQL">set @变量名=值;
call 存储过程名(@变量名);
select @变量名;
</code></pre>
</li>
</ul>
<h4 id="三-删除存储过程">三、删除存储过程</h4>
<pre><code class="language-mySQL">drop procedure 存储过程名;
</code></pre>
<h4 id="四-查看存储过程的信息">四、查看存储过程的信息</h4>
<pre><code class="language-mySQL">show create procedure 存储过程名;
</code></pre>
<h3 id="函数">函数</h3>
<ul>
<li>与存储过程的区别
<ul>
<li>存储过程可以有0个或多个返回，适合批量插入、批量更新</li>
<li>函数有且仅有1个返回，适合处理数据后返回一个结果</li>
</ul>
</li>
</ul>
<h4 id="一-创建语法-2">一、创建语法</h4>
<pre><code class="language-mySQL">create function 函数名(参数列表) returns 返回类型
begin
	函数体
end
</code></pre>
<ul>
<li>注意
<ol>
<li>参数列表包含两部分：参数名 参数类型</li>
<li>函数体：肯定有return语句，一般放在函数体最后</li>
<li>如果函数体中只有一句话，则可以省略begin end</li>
<li>使用delimiter语句设置结束标记</li>
</ol>
</li>
</ul>
<h4 id="二-调用语法-2">二、调用语法</h4>
<pre><code class="language-mySQL">select 函数名(实参列表);
</code></pre>
<h4 id="三-查看函数">三、查看函数</h4>
<pre><code class="language-mySQL">show create function 函数名;
</code></pre>
<h4 id="四-删除函数">四、删除函数</h4>
<pre><code class="language-mySQL">drop function 函数名;
</code></pre>
<h2 id="流程控制结构">流程控制结构</h2>
<h3 id="一-分支结构">一、分支结构</h3>
<h4 id="1-if函数">1. if函数</h4>
<ul>
<li>
<p>功能：简单实现的双分支</p>
</li>
<li>
<p>位置：可以作为表达式放在begin end里面或外面</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">if(表达式1,表达式2,表达式3)
执行顺序：如果表达式1成立则if函数返回表达式2的值，否则返回表达式3的值
</code></pre>
</li>
</ul>
<h4 id="2-case结构">2、case结构</h4>
<p>情况1：类似于Java中的switch语句，一般用于实现等值判断</p>
<ul>
<li>
<p>语法：</p>
<ul>
<li>
<p>作为表达式</p>
<pre><code class="language-mySQL">case 变量|表达式|字段
when 要判断的值 then 返回的值1
when 要判断的值 then 返回的值2
...
else 要返回的值n
end;
</code></pre>
</li>
<li>
<p>作为独立的语句</p>
<pre><code class="language-mySQL">case 变量|表达式|字段
when 要判断的值 then 返回的语句1;
when 要判断的值 then 返回的语句2;
...
else 要返回的语句n;
end case;
</code></pre>
</li>
</ul>
</li>
</ul>
<p>情况2：类似于Java中的多重if语句，一般用于实现区间判断</p>
<ul>
<li>
<p>语法：</p>
<ul>
<li>
<p>作为表达式</p>
<pre><code class="language-mySQL">case
when 要判断的条件1 then 返回的值1
when 要判断的条件2 then 返回的值2
...
else 要返回的值n
end;
</code></pre>
</li>
<li>
<p>作为独立的语句</p>
<pre><code class="language-mySQL">case
when 要判断的条件1 then 返回的语句1;
when 要判断的条件2 then 返回的语句2;
...
else 要返回的语句n;
end case;
</code></pre>
</li>
</ul>
</li>
</ul>
<p>特点：</p>
<ol>
<li>
<p>可以作为表达式，嵌套在其他语句中使用，此时可以放在任何地方，begin end中或begin end的外面；</p>
<p>可以作为独立的语句去使用，此时只能放在begin end中</p>
</li>
<li>
<p>如果when中的值满足或条件成立，则执行对应的then后面的语句，并且结束case；</p>
<p>如果都不满足，则执行else中的语句或值</p>
</li>
<li>
<p>else可以省略，如果省略else并且所有的when条件都不满足，则返回null</p>
</li>
</ol>
<h4 id="3-if结构">3. if结构</h4>
<ul>
<li>
<p>功能：实现多重分支</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">if 条件1 then 语句1;
elseif 条件2 then 语句2;
...
【else 语句n;】
end if;
</code></pre>
</li>
<li>
<p>特点：只能用在begin end中</p>
</li>
</ul>
<h3 id="二-循环结构">二、循环结构</h3>
<ul>
<li>分类：while,loop,repeat</li>
<li>位置：只能放在begin end中</li>
<li>循环控制：
<ul>
<li>iterate：类似于continue，结束本次循环，继续下一次</li>
<li>leave：类似于break，结束当前所在的循环</li>
</ul>
</li>
<li>三种循环都可以省略名称，但如果循环中添加了循环控制语句（leave或iterate）则必须添加名称</li>
</ul>
<h4 id="1-while">1. while</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">【标签:】while 循环条件 do
		循环体;
end while【标签】;
</code></pre>
</li>
<li>
<p>特点：先判断后执行</p>
</li>
</ul>
<h4 id="2-loop">2. loop</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">【标签:】loop
		循环体;
end loop【标签】;
</code></pre>
<p>可以用来实现简单的死循环</p>
</li>
</ul>
<h4 id="3-repeat">3. repeat</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">【标签:】repeat
		循环体;
until 结束循环的条件
end repeat【标签】;
</code></pre>
</li>
<li>
<p>特点：先执行后判断，无条件至少执行一次</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java内存模型及分区]]></title>
        <id>https://MOMENTUMxx.github.io/post/java-nei-cun-mo-xing-ji-fen-qu/</id>
        <link href="https://MOMENTUMxx.github.io/post/java-nei-cun-mo-xing-ji-fen-qu/">
        </link>
        <updated>2020-10-08T09:45:36.000Z</updated>
        <summary type="html"><![CDATA[<p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人想出来。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人想出来。</p>
<!-- more -->
<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，如图所示。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602150845291.png" alt="Java虚拟机运行时数据区" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi>a</mi><mi>v</mi><mi>a</mi><mi mathvariant="normal">虚</mi><mi mathvariant="normal">拟</mi><mi mathvariant="normal">机</mi><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">区</mi></mrow><annotation encoding="application/x-tex">Java虚拟机运行时数据区
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">虚</span><span class="mord cjk_fallback">拟</span><span class="mord cjk_fallback">机</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">区</span></span></span></span></span></p>
<p>这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p>
<h1 id="程序计数器">程序计数器</h1>
<p>程序计数器可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等基础功能都需要依赖这个计数器来完成。<br>
由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，<strong>每条线程都需要有一个独立的程序计数器</strong>，各条线程之间计数器互不影响，独立存储，为<strong>线程私有</strong>的内存。<br>
如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。<br>
<strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></p>
<h1 id="java虚拟机栈">Java虚拟机栈</h1>
<p>Java虚拟机栈是<strong>线程私有</strong>的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的时候都会同时创建一个栈帧用于<strong>存储局部变量表、操作栈、动态连接、方法出口</strong>等信息。每一个方法从被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程，如下图所示。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602157809259.png" alt="" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi>a</mi><mi>v</mi><mi>a</mi><mi mathvariant="normal">虚</mi><mi mathvariant="normal">拟</mi><mi mathvariant="normal">机</mi><mi mathvariant="normal">栈</mi></mrow><annotation encoding="application/x-tex">Java虚拟机栈
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">虚</span><span class="mord cjk_fallback">拟</span><span class="mord cjk_fallback">机</span><span class="mord cjk_fallback">栈</span></span></span></span></span></p>
<p><strong>局部变量表</strong>用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>，其大小在代码编译期间已经确定，在方法运行期间不会改变。局部变量表以<strong>变量槽</strong>（Slot）为最小存储单位，每个Slot能够存放基本数据类型（boolean、byte、char、short、int、long、float、double）、对象引用（reference类型）或是returnAddress类型（指向了一条字节码指令的地址）。<br>
在《Java虚拟机规范》中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出<code>OutOfMemoryError</code>异常。</p>
<h1 id="本地方法栈">本地方法栈</h1>
<p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则<strong>为虚拟机使用到的Native方法服务</strong>。<br>
与虚拟机栈一样，本地方法栈区域也会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</p>
<h1 id="java堆">Java堆</h1>
<p>Java堆是<strong>被所有线程共享</strong>的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是<strong>存放对象实例</strong>，所有的对象实例以及数组都要在堆上分配。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“<strong>GC堆</strong>”。<br>
从内存回收的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆还可以细分为<strong>新生代</strong>、<strong>老年代</strong>和<strong>永久代</strong>，新生代又包括<code>Eden</code>空间、<code>From Survivor</code>空间和<code>To Survivor</code>空间。<br>
从内存分配的角度看，所有线程共享的Java堆中可以划分出多个线程私有的<strong>分配缓冲区</strong>（Thread Local Allocation Buffer, <strong>TLAB</strong>），以提升对象分配时的效率。<br>
根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的。<br>
如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p>
<h1 id="方法区">方法区</h1>
<p>方法区与Java堆一样是<strong>所有线程共享</strong>的内存区域，用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量和即时编译器编译后的代码缓存</strong>等数据。虽然《Java虚拟机规范》把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做<strong>Non-Heap（非堆）</strong>，目的是与Java堆区分开。<br>
《Java虚拟机规范》对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对<strong>常量池的回收</strong>和对<strong>类型的卸载</strong>，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。<br>
根据《Java虚拟机规范》的规定，当方法区无法满足新的内存分配需求时，将抛出<code>OutOfMemoryError</code>异常。<br>
运行时常量池是方法区的一部分，用于存放编译期生成的各种字面常量和符号引用，当常量池无法再申请到内存时会抛出<code>OutOfMemoryError</code>异常。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM内存分配与回收策略]]></title>
        <id>https://MOMENTUMxx.github.io/post/jvm-nei-cun-fen-pei-yu-hui-shou-ce-lue/</id>
        <link href="https://MOMENTUMxx.github.io/post/jvm-nei-cun-fen-pei-yu-hui-shou-ce-lue/">
        </link>
        <updated>2020-10-08T07:18:33.000Z</updated>
        <summary type="html"><![CDATA[<p>Java技术体系的自动内存管理，最根本的目标是自动化的解决两个问题：自动给对象分配内存以及回收分配给对象的内存。关于回收内存，请见博客中JVM垃圾收集的相关文章，本文主要来探讨一下关于给对象分配内存的那些事儿😉</p>
]]></summary>
        <content type="html"><![CDATA[<p>Java技术体系的自动内存管理，最根本的目标是自动化的解决两个问题：自动给对象分配内存以及回收分配给对象的内存。关于回收内存，请见博客中JVM垃圾收集的相关文章，本文主要来探讨一下关于给对象分配内存的那些事儿😉</p>
<!-- more -->
<h1 id="jvm堆的结构分析新生代-老年代-永久代">JVM堆的结构分析（新生代、老年代、永久代）</h1>
<h2 id="堆分代的目的">堆分代的目的</h2>
<p>为了优化GC时的性能。如果没有分代，所有的对象都是在一起的，GC的时候我们要找到哪些对象没用，就需要对堆的所有区域进行扫描。而堆中的很多对象都是朝生夕死的，分代以后就可以把新创建的对象放到某一区域，当GC的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间来。</p>
<h2 id="年轻代中的gc">年轻代中的GC</h2>
<p>HotSpot虚拟机把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。<br>
因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是<strong>复制算法</strong>，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。<br>
在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602142893177.png" alt="Minor GC示意图" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>i</mi><mi>n</mi><mi>o</mi><mi>r</mi><mi>G</mi><mi>C</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">图</mi></mrow><annotation encoding="application/x-tex">Minor GC示意图
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">图</span></span></span></span></span></p>
<h2 id="有关年轻代的jvm参数">有关年轻代的JVM参数</h2>
<ul>
<li>-XX:NewSize和-XX:MaxNewSize<br>
用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。</li>
<li>-XX:SurvivorRatio<br>
用于设置Eden和其中一个Survivor的比值，这个值也比较重要。</li>
<li>-XX:+PrintTenuringDistribution<br>
用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。</li>
<li>-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold<br>
设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。</li>
</ul>
<h1 id="内存分配策略">内存分配策略</h1>
<h2 id="对象优先在eden分配">对象优先在Eden分配</h2>
<p>大多数情况下，对象在新生代Eden中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。<br>
<strong>Minor GC和Full GC的区别：</strong><br>
- 新生代GC (Minor GC)：指发生在新生代的垃圾收集动作，因为Java时象大多都具备朝生夕灭的特性，所以 Minor GC非常倾繁，一般回收速度也比较快。<br>
- 老年代GC (Major GC / Full GC )：指发生在老年代的GC，出现了 Major GC，经常会伴随至少一次的 Minor GC，Major GC的速度一般会比Minor GC慢10倍以上。</p>
<h2 id="大对象直接进入老年代">大对象直接进入老年代</h2>
<p>大对象就是指需要大量连续内存空间的Java对象，最典型的大对象就是很长的字符串，或者元素数量很庞大的数组。我们在写程序时要避免“朝生夕死”的“短命大对象”，原因是在分配空间时它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着高额的内存复制开销。虚拟机提供了一个-XX: PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法收集内存）。</p>
<h2 id="长期存活的对象将进入老年代">长期存活的对象将进入老年代</h2>
<p>HotSpot虚拟机采用分代收集的思想来管理虚拟机内存。虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并且经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将其年龄设定为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就会被晋升到老年代。对象晋升到老年代的年龄阈值可以通过-XX:MaxTenuringThreshold设置。</p>
<h2 id="动态对象年龄判定">动态对象年龄判定</h2>
<p>虚拟并不是永远都要求对象年龄必须达到MaxTenuringThreshold才能晋升为老年代的，如果在Survivor的空间相同年龄的所有对象大小总和大于Survivor空间的一半时，年龄大于或者等于该年龄的对象直接进入老年代，无需要等到MaxTenuringThreshold中要求的年龄。</p>
<h2 id="空间分配担保">空间分配担保</h2>
<p>在发生Minor GC之前，虚拟机会先检查老年代可用的连续空间是否大于新生代所有对象总空间，如果条件成立，那么这次Minor GC就可以保证安全。否则虚拟机会查看-XX:HandlePromotionFailure参数的设置值是否允许担保失败；如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX:HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。<br>
解释一下这里的“冒险”是指什么，<strong>新生代使用复制收集算法</strong>，但为了提高内存利用率，只用一个Survivor空间来作为轮换备份，当大量对象在Minor GC后都存活下来时（最极端情况是所有对象都存活），Survivor空间无法容纳所有活下来的对象，这时候需要老年代进行分配担保，来减轻Survivor的压力。担保的前提是老年代有足够的空间，但本次回收中一共有多少对象会存活下来是无法提前知道的，只能用历次晋升到老年代对象的平均大小作为经验值，这其实是一种赌概率的方法，如果出现了担保失败，就只好老老实实的发起一次Full GC。虽然有失败的风险，但通常还是会将-XX:HandlePromotionFailure开关打开，避免Full GC过于频繁。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搭建你的专属博客]]></title>
        <id>https://MOMENTUMxx.github.io/post/ge-ren-bo-ke-de-da-jian-ji-yu-dao-de-yi-xie-wen-ti/</id>
        <link href="https://MOMENTUMxx.github.io/post/ge-ren-bo-ke-de-da-jian-ji-yu-dao-de-yi-xie-wen-ti/">
        </link>
        <updated>2020-08-13T07:45:15.000Z</updated>
        <summary type="html"><![CDATA[<p>最近搭建了一个简易的个人博客，正好有时间将这个过程大致记录下来，方便自己日后的查看，也希望能帮助到有需要的人😏😏<br>
关键词：github pages，freenom，cloudflare，gridea</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近搭建了一个简易的个人博客，正好有时间将这个过程大致记录下来，方便自己日后的查看，也希望能帮助到有需要的人😏😏<br>
关键词：github pages，freenom，cloudflare，gridea</p>
<!-- more -->
<h1 id="搭建github-pages">搭建GitHub Pages</h1>
<p>GitHub Pages是一个轻量级的个人博客服务，具有以下的一些优势:</p>
<ul>
<li>完全免费</li>
<li>无须购买云服务进行搭建，只需按步骤一步步操作</li>
<li>支持的功能丰富，可以绑定域名、使用免费的HTTPS、DIY网站的主题、使用插件...</li>
<li>GitHub会替我们处理系统维护、文件存储一类的事情，我们只需要专注于文章的创作<br>
首先需要一个GitHub的账号，在个人主页中创建一个新的Repository<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597306995353.png" alt="" loading="lazy"><br>
在 Repository name 的位置填写域名，格式：用户名.github.io<br>
创建成功后点击右上角Settings,找到 GitHub Pages 选项，选择一个 GitHub 官方提供的主题<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597307223084.jpg" alt="" loading="lazy"><br>
随意选择一个主题后GitHub Pages 就会自动帮你生成好网站，在跳转的界面点击 Commit changes 按钮，网站就可以访问了<br>
在浏览器输入你的项目名称，也就是 用户名.github.io 即可看到你个人网站的主页啦~<br>
接下来我们还需要配置自定义域名和开启HTTPS功能，稍后会说到如何申请一个免费的域名，将申请到的域名填写在Custom domain一栏，然后勾选Enforce HTTPS即可<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597313250998.png" alt="" loading="lazy"></li>
</ul>
<h1 id="注册freenom免费域名">注册freenom免费域名</h1>
<p>个人博客的搭建少不了用到一枚域名，虽然现在的域名很便宜，但免费的还是香啊~<br>
我们熟知的免费域名有.tk，.ml，.cf等。.tk是南太平洋岛国托克劳的顶级域名，.ml是马里的顶级域名，.cf是中非共和国的域名。以前这些免费域名都是分开注册的，后来都被托管到了freenom，更加方便大家的注册。<br>
话不多说，直接开搞！<br>
首先进入freenom的<a href="http://www.freenom.com">官网</a>，输入一个你喜欢的域名然后点击检查可用性<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597308712913.png" alt="" loading="lazy"><br>
选择一个点击现在获取，然后点击右上角完成<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597308969452.png" alt="" loading="lazy"><br>
选择最长有效期十二个月有效，然后点击continue；需要注意，务必在域名即将到期前，手动续期域名，否则你可能会失去你拥有的域名。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597309052877.png" alt="" loading="lazy"><br>
接下来需要进行邮件验证或是登录谷歌账号，我选择登录谷歌账户（不知道为什么每隔一会儿我的登录信息就会失效要求重新登陆，难道是人品不好？？）<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597309216978.png" alt="" loading="lazy"><br>
登陆以后先别着急，有一个地方需要注意，我们需要处于科学上网的环境，并且地址需要在<strong>美国</strong>，一定要在美国，否则会出问题。所以接下来我们修改自己的个人信息<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597309728208.png" alt="" loading="lazy"><br>
<img src="https://MOMENTUMxx.github.io/post-images/1597309734629.png" alt="" loading="lazy"><br>
地址这里我只是做一个演示，重点是要在美国<br>
更改成功以后就可以进到购物车愉快的下单啦<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597310001604.png" alt="" loading="lazy"><br>
<img src="https://MOMENTUMxx.github.io/post-images/1597310006316.png" alt="" loading="lazy"><br>
至此在freenom申请一个免费的域名就基本完成了，还留下一点点工作，就是配置DNS域名服务器，将其更改成CloudFlare提供给我们的地址（稍后会说到如何获取）<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597323177509.png" alt="" loading="lazy"><br>
<img src="https://MOMENTUMxx.github.io/post-images/1597312707981.png" alt="" loading="lazy"><br>
<img src="https://MOMENTUMxx.github.io/post-images/1597312713919.png" alt="" loading="lazy"><br>
<img src="https://MOMENTUMxx.github.io/post-images/1597312719261.png" alt="" loading="lazy"></p>
<h1 id="给个人博客套上cdn加速">给个人博客套上CDN加速</h1>
<p>CDN的全称是Content Delivery Network，即内容分发网络。简单来说就是套上CDN之后会隐藏你的真实IP，访客会通过访问就近CDN服务器再访问你的网站，能保证网站访问速度，降低延迟，能抵御一定的攻击。通俗一点来说就是网络加速器，但是目前国内的CDN加速服务都是收费的，包括腾讯云、阿里云都提供相关服务。而且国内需要备案。所以我们选择Cloudflare（也叫cf）<br>
还是先来到<a href="https://www.cloudflare.com/">官网</a>，注册并登录<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597310725765.png" alt="" loading="lazy"><br>
选择添加站点到下一步，这里的站点输入我们刚才在freenom免费申请的域名<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597310732345.png" alt="" loading="lazy"><br>
之后会要求我们选择一个计划，我们选择一个免费的即可，跟着提示信息走就可以了<br>
有两个地方是需要我们来关注的：</p>
<ol>
<li>我们需要添加DNS记录：<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597311520674.png" alt="" loading="lazy"><br>
类型这里可以根据需求进行选择，如你想要解析到一个IPV4地址，则选择&quot;A&quot;;如你想要解析到一个IPV6地址，则选择&quot;AAAA&quot;;如你需要将域名指向另一个域名，再由另一个域名提供ip地址，则选择&quot;CNAME&quot;等等诸如此类，具体可查看类型介绍<br>
因为我们的博客托管到GitHub Pages上，所以这里的类型选择CNAME，名称填写在freenom申请到的域名，目标填写在GitHub Pages上的项目地址也就是 用户名.github.io，TTL选择自动即可，然后将后面的云朵点亮表示通过通过 Cloudflare 代理流量</li>
<li>另一个需要关注的地方就是Cloudflare为我们提供的域名服务器，把它们填写在之前提过的在freenom配置DNS的位置就可以了，同时修改成功后会收到dns服务器修改成功的邮件<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597312287482.png" alt="" loading="lazy"><br>
CloudFlare有一些好用的功能，比如：</li>
</ol>
<ul>
<li>免费且快速的DNS服务</li>
<li>免费的SSL证书</li>
<li>限制某些地区的IP访问等操作</li>
<li>防止网络攻击</li>
<li>网站缓存和加速</li>
<li>一个cloudflare账户免费绑定多个网站<br>
更加详细的使用教程可以参考<a href="https://www.jianshu.com/p/1e73c2d66ac8">这里</a></li>
</ul>
<h1 id="gridea-更方便的管理github-pages">Gridea--更方便的管理GitHub Pages</h1>
<p>点击<a href="https://gridea.dev/">这里</a>进入官网下载Gridea的客户端，虽然搭建博客的过程可能让你觉得简单，但是管理和推送文章却相对麻烦不少，在<a href="https://pages.github.com/">官方教程</a>里，我们需要经历繁琐的步骤才能发布一篇文章和修改个人空间界面。相较于官方提供的 GitHub Desktop 和在终端使用 Git 的方法管理 Github Pages，Gridea 这款工具则更为的便捷和优雅，它能让作为创作者的你更专注于写作<br>
接下来我们说一下Gridea的配置和基本使用方法<br>
首先是基本配置<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597313686244.png" alt="" loading="lazy"><br>
还是比较直观的，平台选择GitHub Pages，域名选择 https:// 然后填写 用户名.github.io，令牌在<a href="https://github.com/settings/tokens">这里</a>获取，CNAME填写我们在freenom申请到的域名<br>
这里有个安全上的小 Tip，我们在创建 Personal access tokens 的时候，只需要赋予 repo 的权限即可，这样最大程度减少 Token 出现泄漏后可能造成的安全风险。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597313962084.png" alt="" loading="lazy"><br>
配置好后可以点击“检测远程连接”按钮进行测试<br>
Gridea可以让你选择使用不同的主题来满足你的个性化需求，在<a href="https://gridea.dev/themes/">这里</a>可以看到官网上的主题市场，快去选择一款酷炫的主题并自定义它的配置吧~</p>
<h1 id="可能遇到的问题及解决方法">可能遇到的问题及解决方法</h1>
<ol>
<li>使用CloudFlare后提示“将您重定向的次数过多”<br>
原因：如果服务器设置了HTTP重定向到HTTPS，由于CloudFlare CDN默认SSL设置为“Flexible”模式（HTTP请求），这时服务器对于CloudFlare的响应会被加密，从而访问失败并不断重复发送相同请求。访问网站会提示“将您重定向的次数过多”或“ERR_TOO_MANY_REDIRECTS”错误，按提示清除浏览器Cookie也没用<br>
解决方法：只需调整CloudFlare后台Crypto页面里的SSL设置，改为 Full 或 Full (strict) 模式（前者不验证服务器证书，后者则会）<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597322269245.png" alt="" loading="lazy"></li>
<li>打开网站后css的样式不对，F12的错误信息为：Mixed Content: The page at 'xxx' was loaded over HTTPS, but requested an insecure resource 'xxx'.<br>
原因：HTTPS页面里动态的引入HTTP资源，比如引入一个js文件，会被直接block掉的.在HTTPS页面里通过AJAX的方式请求HTTP资源，也会被直接block掉的。<br>
解决方法：页面的head中加入：<br>
<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;</code><br>
意思是自动将http的不安全请求升级为https</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://MOMENTUMxx.github.io/post/hello-gridea/</id>
        <link href="https://MOMENTUMxx.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>