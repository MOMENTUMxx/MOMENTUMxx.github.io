<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://MOMENTUMxx.github.io</id>
    <title>王璐杰的BLOG</title>
    <updated>2020-11-20T07:05:12.144Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://MOMENTUMxx.github.io"/>
    <link rel="self" href="https://MOMENTUMxx.github.io/atom.xml"/>
    <subtitle>行百里者半九十</subtitle>
    <logo>https://MOMENTUMxx.github.io/images/avatar.png</logo>
    <icon>https://MOMENTUMxx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 王璐杰的BLOG</rights>
    <entry>
        <title type="html"><![CDATA[LeetCode刷题]]></title>
        <id>https://MOMENTUMxx.github.io/post/leetcode-shua-ti/</id>
        <link href="https://MOMENTUMxx.github.io/post/leetcode-shua-ti/">
        </link>
        <updated>2020-10-12T02:39:47.000Z</updated>
        <summary type="html"><![CDATA[<p>将刷力扣过程中的一些有代表性的类型题和常用的算法做了总结😊</p>
]]></summary>
        <content type="html"><![CDATA[<p>将刷力扣过程中的一些有代表性的类型题和常用的算法做了总结😊</p>
<!-- more -->
<h1 id="动态规划">动态规划</h1>
<h2 id="动态规划0-1背包问题">动态规划0-1背包问题</h2>
<p>1、背包容量为cap，有n个物品，给定体积和价值的两个一维数组w和v，其中w[i]表示第i件物品的体积，v[i]表示第i件物品的价值，在不超过背包容量的前提下使装入背包的物品具有最大的价值总和，返回最大价值</p>
<p>二维dp：</p>
<pre><code class="language-java">class Solution {
    public int bag(int[] w, int[] v, int cap, int n) {
        //dp[i][j]表示当前有i个物品可选,选择其中一些放入容量为j的背包,能得到的最大价值
        int[][] dp = new int[n][cap + 1];
        dp[0][w[0]] = v[0];
        for (int i = 1; i &lt; n; i++) {
            for (int j = 0; j &lt; cap + 1; j++) {
                //先复制再修改
                //背包容量小于第i个物体的体积时,不能放入第i个物体,总价值与物品数量为i-1,背包容量为j时相同
                dp[i][j] = dp[i - 1][j];
                if (j &gt;= w[i]) {
                    //此时有足够的空间来装当前物品,但装了当前物品也不一定达到当前最优价值(可能会让更有价值的物品放不进背包),因此在装与不装之间选择一个最优策略
                    //dp[i-1][j]表示不装当前物品,dp[i-1][j-w[i]]表示装当前物品
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);
                }
            }
        }
        //计算背包内商品的编号
        int[] item = new int[n];
        int j = cap;
        for (int i = n - 1; i &gt; 0; i--) {
            if (dp[i][j] &gt; dp[i - 1][j]) {
                item[i] = 1;
                j -= w[i];
            }
        }
        for (int i = 0; i &lt; n; i++) {
            if (item[i] == 1) {
                System.out.println(i);
            }
        }
        return dp[n - 1][cap];
    }
}
</code></pre>
<p>一维dp：</p>
<pre><code class="language-java">class Solution {
    public int bag(int[] w, int[] v, int cap, int n) {
        int[] dp = new int[cap + 1];
        dp[w[0]] = v[0];
        for (int i = 1; i &lt; n; i++) {
            for (int j = cap; j &gt;= w[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - w[i]] + v[i]);
            }
        }
        return dp[cap];
    }
}
</code></pre>
<p>2、<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a></p>
<p>3、<a href="https://leetcode-cn.com/problems/target-sum/">目标和</a></p>
<h2 id="动态规划完全背包">动态规划完全背包</h2>
<p>1、<a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></p>
<p>2、<a href="https://leetcode-cn.com/problems/coin-lcci/">硬币</a></p>
<h2 id="动态规划博弈论">动态规划博弈论</h2>
<p>1、<a href="https://leetcode-cn.com/problems/predict-the-winner/">预测赢家</a></p>
<p>2、<a href="https://leetcode-cn.com/problems/stone-game/">石子游戏</a></p>
<h1 id="旋转排序数组">旋转排序数组</h1>
<p>1、<a href="https://leetcode-cn.com/problems/search-rotate-array-lcci/">搜索旋转数组</a></p>
<p>2、<a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">旋转数组的最小数字</a></p>
<h1 id="回文">回文</h1>
<p>1、<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">最长回文子序列</a></p>
<p>2、<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></p>
<h1 id="二分查找左右边界">二分查找左右边界</h1>
<pre><code class="language-java">private int binarySearch(int[] array, int target) {
        int leftBound, rightBound, left = 0, right = array.length;
        //找左边界
        while (left &lt; right) {
            int mid = ((right - left) &gt;&gt; 1) + left;
            if (array[mid] &gt;= target) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        leftBound = left &gt;= array.length ? -1 : left;
        System.out.println(&quot;leftBound:&quot; + leftBound);
        //没找到左边界,说明没有要查找的数,直接退出
        if (leftBound == -1) {
            return 0;
        }
        left = leftBound;
        right = array.length;
        //找右边界
        while (left &lt; right) {
            int mid = ((right - left) &gt;&gt; 1) + left;
            if (array[mid] &lt;= target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        rightBound = left - 1;
        System.out.println(&quot;rightBound:&quot; + rightBound);
        System.out.println(rightBound - leftBound + 1);
        return rightBound - leftBound + 1;
    }
</code></pre>
<h1 id="缓存机制">缓存机制</h1>
<p>1、<a href="https://leetcode-cn.com/problems/lru-cache/">LRU （Least Recently Used）</a></p>
<p>2、<a href="https://leetcode-cn.com/problems/lfu-cache/">LFU （Least Frequently Used）</a></p>
<h1 id="树">树</h1>
<h2 id="二叉树遍历之迭代">二叉树遍历之迭代</h2>
<h3 id="1-前序">1. 前序</h3>
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        if (root == null) {
            return ans;
        }
        Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            ans.add(node.val);
            if (node.right != null) {
                stack.push(node.right);
            }
            if (node.left != null) {
                stack.push(node.left);
            }
        }
        return ans;
    }
}
</code></pre>
<h3 id="2-中序">2. 中序</h3>
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()) {
            //向左走到底
            while (cur != null) {
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            ans.add(cur.val);
            //向右走一步
            cur = cur.right;
        }
        return ans;
    }
}
</code></pre>
<h3 id="3-后序">3. 后序</h3>
<pre><code class="language-java">class Solution {
    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        if (root == null) {
            return ans;q
        }
        Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();
        stack.add(root);
        //保存后续遍历的倒序:根-&gt;右-&gt;左
        while (!stack.isEmpty()) {
            TreeNode node = stack.removeFirst();
            ans.add(node.val);
            if (node.left != null) {
                stack.addFirst(node.left);
            }
            if (node.right != null) {
                stack.addFirst(node.right);
            }
        }
        Collections.reverse(ans);
        return ans;
    }
}
</code></pre>
<h2 id="二叉树搜索树的插入操作">二叉树搜索树的插入操作</h2>
<ol>
<li>
<p>迭代</p>
<pre><code class="language-java">class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        TreeNode node = new TreeNode(val);
        if (root == null) {
            return node;
        }
        TreeNode cur = root;
        while (true) {
            if (cur.val &gt; val) {
                if (cur.left == null) {
                    cur.left = node;
                    break;
                }
                cur = cur.left;
            } else {
                if (cur.right == null) {
                    cur.right = node;
                    break;
                }
                cur = cur.right;
            }
        }
        return root;
    }
}
</code></pre>
</li>
<li>
<p>递归</p>
<pre><code class="language-java">class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) {
            return new TreeNode(val);
        }
        if (root.val &lt; val) {
            root.right = insertIntoBST(root.right, val);
        } else {
            root.left = insertIntoBST(root.left, val);
        }
        return root;
    }
} 
</code></pre>
</li>
</ol>
<h2 id="完全二叉树的节点个数">完全二叉树的节点个数</h2>
<p>1、<a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">完全二叉树的节点个数</a></p>
<h2 id="前缀树">前缀树</h2>
<p>1、<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">实现 Trie (前缀树)</a></p>
<p>2、<a href="https://leetcode-cn.com/problems/t9-lcci/">T9键盘</a></p>
<h1 id="最长递增子序列lis">最长递增子序列（LIS）</h1>
<p>1、<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长上升子序列</a></p>
<p>2、<a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">俄罗斯套娃信封问题</a></p>
<p>3、<a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/comments/">最长递增子序列的个数</a></p>
<h1 id="记忆化dfs返回值int">记忆化DFS（返回值int）</h1>
<p>1、<a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">矩阵中的最长递增路径</a></p>
<h1 id="并查集">并查集</h1>
<p>1、<a href="https://leetcode-cn.com/problems/friend-circles/">朋友圈</a></p>
<h1 id="滑动窗口">滑动窗口</h1>
<p>1、<a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/submissions/">替换后的最长重复字符</a></p>
<h1 id="单调栈">单调栈</h1>
<p>1、<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></p>
<p>2、<a href="https://leetcode-cn.com/problems/trapping-rain-water/submissions/">接雨水</a></p>
<h1 id="排序">排序</h1>
<h2 id="归并排序">归并排序</h2>
<pre><code class="language-java">//自顶向下的归并排序
class Solution {
    //数组小于等于这个临界值将优先使用插入排序
    private static final int INSERTION_SORT_THRESHOLD = 7;

    public int[] sortArray(int[] nums) {
        int len = nums.length;
        //用于合并两个有序数组的辅助数组,全局使用一份,避免多次创建和销毁
        int[] tmp = new int[len];
        mergeSort(nums, 0, len - 1, tmp);
        return nums;
    }

    //对数组nums的子区间[left,right]进行归并排序
    private void mergeSort(int[] nums, int left, int right, int[] tmp) {
        //小区间使用插入排序
        if (right - left &lt;= INSERTION_SORT_THRESHOLD) {
            insertionSort(nums, left, right);
            return;
        }
        int mid = left + ((right - left) &gt;&gt; 1);
        mergeSort(nums, left, mid, tmp);
        mergeSort(nums, mid + 1, right, tmp);
        //如果数组的这个子区间本身有序,无需合并
        if (nums[mid] &lt;= nums[mid + 1]) {
            return;
        }
        mergeOfTwoSortedArray(nums, left, mid, right, tmp);
    }

    //合并两个有序数组:先把值复制到临时数组,再合并回去
    private void mergeOfTwoSortedArray(int[] nums, int left, int mid, int right, int[] tmp) {
        System.arraycopy(nums, left, tmp, left, right - left + 1);
        int i = left;
        int j = mid + 1;
        for (int k = left; k &lt;= right; k++) {
            //左半边用尽,取右边的值
            if (i == mid + 1) {
                nums[k] = tmp[j];
                j++;
            } else if (j == right + 1) {
                //右半边用尽,取左边的值
                nums[k] = tmp[i];
                i++;
            } else if (tmp[i] &lt;= tmp[j]) {
                //注意如果写成&lt;就丢失了稳定性(相同元素原来靠前的排序后依然靠前)
                nums[k] = tmp[i];
                i++;
            } else {
                nums[k] = tmp[j];
                j++;
            }
        }
    }

    //插入排序,左右边界均能取到
    private void insertionSort(int[] arr, int left, int right) {
        for (int i = left + 1; i &lt;= right; i++) {
            int tmp = arr[i], j = i;
            //将较大的元素向右移动
            while (j &gt; left &amp;&amp; arr[j - 1] &gt; tmp) {
                arr[j] = arr[j - 1];
                j--;
            }
            arr[j] = tmp;
        }
    }
}
</code></pre>
<p>1、<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a></p>
<h2 id="快速排序">快速排序</h2>
<pre><code class="language-java">//双指针(指针对撞)快速排序
public class Solution {
    //数组小于等于这个临界值将优先使用插入排序
    private static final int INSERTION_SORT_THRESHOLD = 7;
    private static final Random RANDOM = new Random();

    public int[] sortArray(int[] nums) {
        int len = nums.length;
        quickSort(nums, 0, len - 1);
        return nums;
    }

    private void quickSort(int[] nums, int left, int right) {
        //小区间使用插入排序
        if (right - left &lt;= INSERTION_SORT_THRESHOLD) {
            insertionSort(nums, left, right);
            return;
        }
        int pIndex = partition(nums, left, right);
        quickSort(nums, left, pIndex - 1);
        quickSort(nums, pIndex + 1, right);
    }

    private int partition(int[] nums, int left, int right) {
        int randomIndex = RANDOM.nextInt(right - left + 1) + left;
        swap(nums, left, randomIndex);
        //基准值
        int pivot = nums[left];
        int lt = left + 1, gt = right;
        while (true) {
            //all in [left + 1, lt) &lt;= pivot
            while (lt &lt;= right &amp;&amp; nums[lt] &lt; pivot) {
                lt++;
            }
            //all in (gt, right] &gt;= pivot
            while (gt &gt; left &amp;&amp; nums[gt] &gt; pivot) {
                gt--;
            }
            if (lt &gt;= gt) {
                break;
            }
            //细节：交换相等的元素，等概率分到数组两边，可以保证在某些应用中避免运行时间变为平方级别
            swap(nums, lt, gt);
            //这里更新是为了避免两个相等元素陷入死循环
            lt++;
            gt--;
        }
        //gt所在位置的值小于pivot
        swap(nums, left, gt);
        return gt;
    }

    private void swap(int[] nums, int idx1, int idx2) {
        int tmp = nums[idx1];
        nums[idx1] = nums[idx2];
        nums[idx2] = tmp;
    }
    
    //插入排序,左右边界均能取到
    private void insertionSort(int[] arr, int left, int right) {
        for (int i = left + 1; i &lt;= right; i++) {
            int tmp = arr[i], j = i;
            //将较大的元素向右移动
            while (j &gt; left &amp;&amp; arr[j - 1] &gt; tmp) {
                arr[j] = arr[j - 1];
                j--;
            }
            arr[j] = tmp;
        }
    }
}
</code></pre>
<pre><code class="language-java">//三指针快速排序
public class Solution {
    //数组小于等于这个临界值将优先使用插入排序
    private static final int INSERTION_SORT_THRESHOLD = 7;
    private static final Random RANDOM = new Random();

    public int[] sortArray(int[] nums) {
        int len = nums.length;
        quickSort(nums, 0, len - 1);
        return nums;
    }

    private void quickSort(int[] nums, int left, int right) {
        if (right - left &lt;= INSERTION_SORT_THRESHOLD) {
            insertionSort(nums, left, right);
            return;
        }
        int randomIndex = RANDOM.nextInt(right - left + 1) + left;
        swap(nums, left, randomIndex);
        //基准值
        int pivot = nums[left];
        // 循环不变量：
        // all in [left + 1, lt] &lt; pivot
        // all in [lt + 1, i) = pivot
        // all in [gt, right] &gt; pivot
        int lt = left;
        int gt = right + 1;

        int i = left + 1;
        while (i &lt; gt) {
            if (nums[i] &lt; pivot) {
                lt++;
                swap(nums, i, lt);
                i++;
            } else if (nums[i] == pivot) {
                i++;
            } else {
                gt--;
                swap(nums, i, gt);
            }
        }
        //lt所在位置的值小于pivot
        swap(nums, left, lt);
        //大大减少两侧分治的区间
        quickSort(nums, left, lt - 1);
        quickSort(nums, gt, right);
    }

    private void swap(int[] nums, int idx1, int idx2) {
        int tmp = nums[idx1];
        nums[idx1] = nums[idx2];
        nums[idx2] = tmp;
    }

    //插入排序,左右边界均能取到
    private void insertionSort(int[] arr, int left, int right) {
        for (int i = left + 1; i &lt;= right; i++) {
            int tmp = arr[i], j = i;
            //将较大的元素向右移动
            while (j &gt; left &amp;&amp; arr[j - 1] &gt; tmp) {
                arr[j] = arr[j - 1];
                j--;
            }
            arr[j] = tmp;
        }
    }
}
</code></pre>
<p>1、<a href="https://leetcode-cn.com/problems/sort-colors/">颜色分类</a></p>
<p>2、<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></p>
<p>3、<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">最小的k个数</a></p>
<h1 id="链表">链表</h1>
<h2 id="快慢指针找中间节点">快慢指针找中间节点</h2>
<pre><code class="language-java">//找第一个中间节点
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head, fast = head;
        while (fast.next != null &amp;&amp; fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}

//找第二个中间节点
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head, fast = head;
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
</code></pre>
<h2 id="翻转链表">翻转链表</h2>
<pre><code class="language-java">//以1-&gt;2-&gt;3-&gt;4为例，翻转过程如下
//1. 1   2-&gt;3-&gt;4
//2. 2-&gt;1   3-&gt;4
//3. 3-&gt;2-&gt;1   4
//4. 4-&gt;3-&gt;2-&gt;1
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode tmp, ans = null;
        while (head != null) {
            tmp = head.next;
            head.next = ans;
            ans = head;
            head = tmp;
        }
        return ans;
    }
}
</code></pre>
<p>1、<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第N个节点</a></p>
<p>2、<a href="https://leetcode-cn.com/problems/reorder-list/">重排链表</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java垃圾收集]]></title>
        <id>https://MOMENTUMxx.github.io/post/java-la-ji-shou-ji/</id>
        <link href="https://MOMENTUMxx.github.io/post/java-la-ji-shou-ji/">
        </link>
        <updated>2020-10-11T08:21:21.000Z</updated>
        <summary type="html"><![CDATA[<p>🚀本文主要总结了有关JVM垃圾收集的那些事儿，包括判断对象是否存活、各种引用方式、垃圾收集算法以及常用的垃圾收集器...</p>
]]></summary>
        <content type="html"><![CDATA[<p>🚀本文主要总结了有关JVM垃圾收集的那些事儿，包括判断对象是否存活、各种引用方式、垃圾收集算法以及常用的垃圾收集器...</p>
<!-- more -->
<p>垃圾收集需要完成三件事情：哪些内存需要回收？什么时候回收？如何回收？之前说过Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出执行入栈和出栈的操作。每一个栈帧分配多少内存是在编译期就<strong>已知</strong>的，因此这几个区域的内存分配和回收都具有确定性，不需要过多考虑如何回收的问题，当方法结束或线程结束时，内存自然就跟着回收了。<br>
而Java堆和方法区则有很大的不确定性，如一个接口的多个实现类或一个方法执行的不同条件分支所需要的内存都是不确定的，只有在运行期才能知晓，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理。</p>
<h1 id="判断对象是否死去">判断对象是否死去</h1>
<p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器对堆内存进行回收前，都会先判断这些对象之中哪些还“存活”着，哪些已经“死去”(即不可能在被任何途径使用的对象)。</p>
<h2 id="引用计数算法">引用计数算法</h2>
<p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。<br>
优点：原理简单，判定效率高<br>
缺点：难以解决对象之间相互<strong>循环引用</strong>的问题<br>
主流的Java虚拟机都没有选用引用计数算法来管理内存。</p>
<h2 id="可达性分析算法">可达性分析算法</h2>
<p>通过一系列的称为“<strong>GC Roots</strong>”的对象作为起始点，从这些节点开始向下搜索，搜索过程所走过的路径称为<strong>引用链</strong>(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602663773077.png" alt="" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">利</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">达</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">分</mi><mi mathvariant="normal">析</mi><mi mathvariant="normal">算</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">判</mi><mi mathvariant="normal">断</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">象</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">否</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">回</mi><mi mathvariant="normal">收</mi></mrow><annotation encoding="application/x-tex">利用可达性分析算法判断对象是否可回收
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">利</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">达</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">析</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">判</span><span class="mord cjk_fallback">断</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">回</span><span class="mord cjk_fallback">收</span></span></span></span></span></p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用。</li>
<li>所有被同步锁持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<h2 id="引用">引用</h2>
<p>推荐参考文章<a href="https://blog.csdn.net/baidu_22254181/article/details/82555485">https://blog.csdn.net/baidu_22254181/article/details/82555485</a></p>
<ol>
<li>强引用：强引用是在程序代码之中普遍存在的引用赋值，类似<code>Object o = new Object()</code>这种引用关系。无论任何情况下，只要强引用关系还在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>软引用：用来描述一些还有用但<strong>非必须</strong>的对象。只被软引用关联的对象，在系统要发生内存溢出异常前，会把这些对象列进回收范围之中进行二次回收，如果这次回收还是没有足够的内存，才会抛出溢出异常。<br>
应用场景：做缓存（浏览器的后退按钮）</li>
<li>弱引用：也是用来描述那些<strong>非必须</strong>对象，但它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作时，<strong>无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>。</li>
<li>虚引用：最弱的一种引用关系，一个对象是否有虚引用的存在，<strong>完全不会对其生存时间构成影响</strong>，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的只是为了在这个对象被收集器回收时收到一个系统通知。</li>
</ol>
<h2 id="对象的生存与死亡">对象的生存与死亡</h2>
<p>在可达性分析算法中判定为不可达的对象，也不是非死不可，要宣告一个对象真正死亡，至少要经历两次标记过程：</p>
<ol>
<li>对象在可达性分析后发现没有与GC Roots相连接的引用链会被第一次标记，然后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或者finalize()方法已经被JVM调用过，那么就没必要执行finalize()方法；</li>
<li>如果被判定为有必要执行finalize()方法，那么此对象将会放置在一个叫做<strong>F-Queue</strong>的队列之中，并在稍后由一个虚拟机自动建立的、低优先级的Finalize线程去触发这个方法。<strong>finalize()<strong>方法是对象逃脱死亡的</strong>最后一次机会</strong>，稍后GC将对F-Queue中的对象进行<strong>第二次小规模的标记</strong>，如果对象要在finalize()中成功拯救自己——只要<strong>重新与引用链上的任何一个对象建立关系</strong>即可，譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量，那么在第二次标记时它将被移出“即将回收”集合；如果对象这时候还没有成功逃脱，那他就会真的被回收了。</li>
</ol>
<pre><code class="language-java">/**
 * 此代码演示了两点： 
 * 1.对象可以被GC时自我拯救 
 * 2.这种自救的机会只有一次，因为一个对象的finzlize()方法最多只会被系统自动调用一次
 */
public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK = null;

    public void isAlive() {
        System.out.println(&quot;yes, i am still alive :)&quot;);
    }

    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println(&quot;finalize method executed!&quot;);
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws Throwable {
        SAVE_HOOK = new FinalizeEscapeGC();

        // 对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();
        // 因为finalize方法优先级很低，所以暂停0.5s以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println(&quot;no, i am dead :(&quot;);
        }

        // 下面这段代码与上面的完全相同，但是这次自救却失败了
        SAVE_HOOK = null;
        System.gc();
        // 因为finalize方法优先级很低，所以暂停0.5s以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println(&quot;no, i am dead :(&quot;);
        }
    }
}
</code></pre>
<p>运行结果：<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602422845509.png" alt="" loading="lazy"><br>
可以看到SAVE_HOOK对象的finalize()方法确实被GC收集器触发了，并且在被收集前成功逃脱了。<br>
注意代码中有两段完全一样的代码片段，执行结果确实一次成功逃脱，一次失败，这是因为任何一个对象的finalize()方法都<strong>只会被系统自动调用一次</strong>，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</p>
<h1 id="垃圾收集算法">垃圾收集算法</h1>
<p>垃圾收集算法可以划分为“引用计数式垃圾收集”(Reference Counting GC,直接垃圾收集)和“追踪式垃圾收集”(Tracing GC,间接垃圾收集)两大类，本文的所有垃圾收集算法均属于追踪式垃圾收集的范畴。</p>
<h2 id="分代收集理论">分代收集理论</h2>
<p>分代假说：</p>
<ol>
<li>弱分代假说：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
<li>跨代引用对于同代引用来说仅占极少数。<br>
上面的假说奠定了多款垃圾收集器一致的设计原则：<strong>收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（熬过GC的次数）分配到不同的区域之中存储。</strong><br>
解释：如果把区域中大多数朝生夕灭的对象集中放在一起，每次回收只关注少量存活而不去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；把难以消亡的对象集中放在一起，虚拟机便可以使用较低的频率来回收这个区域，同时兼顾了垃圾收集的时间开销和内存的空间有效利用。<br>
设计者一般至少会把Java堆划分为新生代和老年代两个区域。<strong>在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</strong><br>
<strong>概念辨析：</strong></li>
</ol>
<ul>
<li>部分收集(Partial GC):指目标不是完整收集整个Java堆的垃圾收集，其中又分为：
<ul>
<li>新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集。</li>
<li>老年代收集(Major GC/Old GC):指目标只是老年代的垃圾收集，目前只有<strong>CMS</strong>收集器会有单独收集老年代的行为。<strong>注意</strong>：&quot;Major GC&quot;这个说法需要按上下文区分是指老年代的收集还是整堆收集。</li>
<li>混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有<strong>G1</strong>收集器会有这种行为。</li>
</ul>
</li>
<li>整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集。</li>
</ul>
<h2 id="标记-清除算法">标记-清除算法</h2>
<p>“标记-清除”算法是最基础的算法，分为“标记”和“清除”两个阶段：<strong>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</strong><br>
缺点：</p>
<ul>
<li>执行效率不稳定；标记和清除两个过程的执行效率随对象数量增长而降低。</li>
<li>内存空间的碎片化问题；标记、清除之后会产生大量不连续的内存碎片，导致当需要分配较大对象时无法找到足够的连续空间而不得不提前触发另一次垃圾收集动作。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602746030129.jpg" alt="" loading="lazy"></li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&quot;</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">记</mi><mo>−</mo><mi mathvariant="normal">清</mi><mi mathvariant="normal">除</mi><mi mathvariant="normal">&quot;</mi><mi mathvariant="normal">算</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">图</mi></mrow><annotation encoding="application/x-tex">&quot;标记-清除&quot;算法示意图
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">&quot;</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">记</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord cjk_fallback">清</span><span class="mord cjk_fallback">除</span><span class="mord">&quot;</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">图</span></span></span></span></span></p>
<h2 id="标记-复制算法针对新生代">标记-复制算法（针对新生代）</h2>
<p>标记-复制算法将可用内存按容量划分为大小相等的两块，每次使用其中的一块。当这块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。<br>
优点：</p>
<ul>
<li>分配内存时不用考虑空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。</li>
</ul>
<p>缺点：</p>
<ul>
<li>将可用内存缩小为了原来的一半，空间浪费多。</li>
</ul>
<p><strong>现在的商业虚拟机都采用复制收集算法来回收新生代</strong>，有研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。<strong>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1</strong>，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，并不能保证每次回收都只有10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行<strong>分配担保（Handle Promotion）</strong>。即如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602750063509.jpg" alt="" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&quot;</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">记</mi><mo>−</mo><mi mathvariant="normal">复</mi><mi mathvariant="normal">制</mi><mi mathvariant="normal">&quot;</mi><mi mathvariant="normal">算</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">图</mi></mrow><annotation encoding="application/x-tex">&quot;标记-复制&quot;算法示意图
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">&quot;</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">记</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">制</span><span class="mord">&quot;</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">图</span></span></span></span></span></p>
<h2 id="标记-整理算法针对老年代">标记-整理算法（针对老年代）</h2>
<p>复制算法在对象存活率较高时就需要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用复制算法。<br>
根据老年代的特点提出了“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向空间一端移动，然后直接清理掉边界以外的内存。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602752646619.jpg" alt="" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&quot;</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">记</mi><mo>−</mo><mi mathvariant="normal">整</mi><mi mathvariant="normal">理</mi><mi mathvariant="normal">&quot;</mi><mi mathvariant="normal">算</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">图</mi></mrow><annotation encoding="application/x-tex">&quot;标记-整理&quot;算法示意图
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">&quot;</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">记</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord cjk_fallback">整</span><span class="mord cjk_fallback">理</span><span class="mord">&quot;</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">图</span></span></span></span></span></p>
<p><strong>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的</strong>。是否移动对象都存在弊端，移动对象操作必须全程暂停用户应用程序才能进行(&quot;Stop The World&quot;)，不移动对象会影响应用程序的吞吐量。</p>
<h1 id="经典垃圾收集器">经典垃圾收集器</h1>
<p>如果说收集算法是内存回收的方法论，那垃圾收集器就是内存回收的实践者。《Java虚拟机规范》中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器。<br>
接下来讨论的是在JDK7 Update 4之后、JDK11正式发布之前，OracleJDK中的HotSpot虚拟机所包含的全部可用的垃圾收集器。<br>
各款经典收集器之间的关系如图所示：<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602837323649.jpg" alt="" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mi>o</mi><mi>t</mi><mi>S</mi><mi>p</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">虚</mi><mi mathvariant="normal">拟</mi><mi mathvariant="normal">机</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">垃</mi><mi mathvariant="normal">圾</mi><mi mathvariant="normal">收</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">器</mi></mrow><annotation encoding="application/x-tex">HotSpot虚拟机的垃圾收集器
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">虚</span><span class="mord cjk_fallback">拟</span><span class="mord cjk_fallback">机</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">垃</span><span class="mord cjk_fallback">圾</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">器</span></span></span></span></span></p>
<p>图中展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用，收集器所处的区域，则表明它是属于新生代收集器或是老年代收集器。</p>
<h2 id="serial-收集器">Serial 收集器</h2>
<p>Serial 收集器是最基本、发展历史最悠久的收集器，是采用<strong>复制算法</strong>的<strong>新生代收集器</strong>，曾经（JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。它是一个单线程收集器，并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须<strong>暂停其他所有的工作线程</strong>，直至收集结束为止(“Stop The World”)。这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接受的。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602839104052.jpg" alt="" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">/</mi><mi>S</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>l</mi><mi>O</mi><mi>l</mi><mi>d</mi><mi mathvariant="normal">收</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">图</mi></mrow><annotation encoding="application/x-tex">Serial/Serial Old收集器运行示意图
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">图</span></span></span></span></span></p>
<p>为了消除或减少工作线程因内存回收而导致的停顿，HotSpot虚拟机开发团队在JDK 1.3之后的Java发展历程中研发出了各种其他的优秀收集器，这些将在稍后介绍。但是这些收集器的诞生并不意味着Serial收集器已经“老而无用”，实际上到现在为止，它依然是<strong>HotSpot虚拟机运行在客户端模式下的默认的新生代收集器</strong>。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。<br>
在用户的桌面应用场景中，分配给虚拟机管理的内存一般不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本不会再大了），停顿时间完全可以控制在几十毫秒最多一百毫秒以内，只要不频繁发生，这点停顿时间可以接受。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。</p>
<h2 id="parnew收集器">ParNew收集器</h2>
<p>ParNew收集器就是<strong>Serial收集器的多线程并行版本</strong>，它也是一个<strong>新生代收集器</strong>。除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（<strong>复制算法</strong>）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同，两者共用了相当多的代码。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1603079279595.jpg" alt="" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>a</mi><mi>r</mi><mi>N</mi><mi>e</mi><mi>w</mi><mi mathvariant="normal">/</mi><mi>S</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>l</mi><mi>O</mi><mi>l</mi><mi>d</mi><mi mathvariant="normal">收</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">图</mi></mrow><annotation encoding="application/x-tex">ParNew/Serial Old 收集器运行示意图
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">图</span></span></span></span></span></p>
<p>ParNew收集器除了支持多线程并行收集外，其他与Serial收集器相比并无太多创新之处，但它却是许多运行在<strong>Server模式下的虚拟机中首选的新生代收集器</strong>，其中有一个与性能无关的重要原因是，除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作。<br>
ParNew 收集器在单CPU的环境中绝对不会有比Serial收集器有更好的效果，在多CPU环境下，随着CPU的数量增加，ParNew对于GC时系统资源的有效利用是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多的情况下可使用<code>-XX:ParallerGCThreads</code>参数来限制垃圾收集的线程数。<br>
概念辨析：</p>
<ul>
<li>并行(Parallel)：<strong>并行描述的是多条垃圾收集器线程之间的关系</strong>，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。</li>
<li>并发(Concurrent)：<strong>并发描述的是垃圾收集器线程与用户线程之间的关系</strong>，说明同一时间垃圾收集器线程与用户线程都在运行。程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序处理的吞吐量将受到一定影响。</li>
</ul>
<h2 id="parallel-scavenge收集器">Parallel Scavenge收集器</h2>
<p>Parallel Scavenge收集器也是一款<strong>新生代收集器</strong>，它同样是基于<strong>标记-复制算法</strong>实现的收集器，也是能够<strong>并行收集的多线程收集器</strong>。<br>
Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能<strong>缩短垃圾收集时用户线程的停顿时间</strong>，而Parallel Scavenge收集器的目标是达到一个<strong>可控制的吞吐量</strong>（Throughput）。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">吞</mi><mi mathvariant="normal">吐</mi><mi mathvariant="normal">量</mi><mo>=</mo><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">户</mi><mi mathvariant="normal">代</mi><mi mathvariant="normal">码</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">户</mi><mi mathvariant="normal">代</mi><mi mathvariant="normal">码</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mo>+</mo><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">垃</mi><mi mathvariant="normal">圾</mi><mi mathvariant="normal">收</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">吞吐量=运行用户代码时间/(运行用户代码时间+运行垃圾收集时间)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">吞</span><span class="mord cjk_fallback">吐</span><span class="mord cjk_fallback">量</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">户</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">码</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord">/</span><span class="mopen">(</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">户</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">码</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">垃</span><span class="mord cjk_fallback">圾</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mclose">)</span></span></span></span></span></p>
<p>停顿时间越短就越适合需要<strong>与用户交互或需要保证服务响应质量的程序</strong>，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用CPU资源，尽快完成程序的运算任务，主要适合<strong>在后台运算而不需要太多交互的分析任务</strong>。<br>
Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的<code>-XX:MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX:GCTimeRatio</code>参数。由于与吞吐量关系密切，Parallel Scavenge收集器也被称作“吞吐量优先收集器”。Parallel Scavenge收集器还有一个参数<code>-XX:+UseAdaptiveSizePolicy</code>，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden和Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为GC的<strong>自适应的调节策略</strong>（GC Ergonomics）。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个<strong>重要区别</strong>。</p>
<h2 id="serial-old收集器">Serial Old收集器</h2>
<p>Serial Old是<strong>Serial的老年代版本</strong>，它同样是一个<strong>单线程收集器</strong>，使用<strong>标记-整理</strong>算法。此收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，它可能有两种用途：</p>
<ul>
<li>在JDK1.5 以及之前版本（Parallel Old诞生以前）中与Parallel Scavenge收集器搭配使用。</li>
<li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1603091499747.jpg" alt="" loading="lazy"></li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">/</mi><mi>S</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>l</mi><mi>O</mi><mi>l</mi><mi>d</mi><mi mathvariant="normal">收</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">图</mi></mrow><annotation encoding="application/x-tex">Serial/Serial Old收集器运行示意图
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">图</span></span></span></span></span></p>
<h2 id="parallel-old收集器">Parallel Old收集器</h2>
<p>Parallel Old收集器是<em><strong>Parallel Scavenge收集器的老年代版本</strong>，支持</em><em>多线程并发收集</em>*，<br>
基于<strong>标记-整理</strong>算法实现。在注重吞吐量或者处理器资源较为稀缺的场合，可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1603092374800.jpg" alt="" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>l</mi><mi>S</mi><mi>c</mi><mi>a</mi><mi>v</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>P</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>l</mi><mi>O</mi><mi>l</mi><mi>d</mi><mi mathvariant="normal">收</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">图</mi></mrow><annotation encoding="application/x-tex">Parallel Scavenge/Parallel Old收集器运行示意图
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">图</span></span></span></span></span></p>
<h2 id="cms收集器">CMS收集器</h2>
<p>CMS（Concurrent Mark Sweep）收集器是一种<strong>以获取最短回收停顿时间为目标的收集器</strong>，基于<strong>标记-清除</strong>算法实现，是一款<strong>老年代收集器</strong>，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。<br>
整个工作流程包括四个步骤：</p>
<ol>
<li><strong>初始标记</strong>：仅仅标记GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。</li>
<li><strong>并发标记</strong>：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长但不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>
<li><strong>重新标记</strong>：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要“Stop The World”。</li>
<li><strong>并发清除</strong>：清理删除标记阶段判断的已经死亡的对象，不需要移动存活对象，可以与用户线程同时并发。<br>
<strong>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</strong><br>
<img src="https://MOMENTUMxx.github.io/post-images/1603093355695.jpg" alt="" loading="lazy"></li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>r</mi><mi>k</mi><mi>S</mi><mi>w</mi><mi>e</mi><mi>e</mi><mi>p</mi><mi mathvariant="normal">收</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">图</mi></mrow><annotation encoding="application/x-tex">Concurrent Mark Sweep 收集器运行示意图
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">图</span></span></span></span></span></p>
<p>优点：</p>
<ul>
<li>并发收集、低停顿，CMS收集器也被称为<strong>并发低停顿收集器</strong>（Concurrent Low Pause Collector）。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>对CPU资源非常敏感</strong>。面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU计算能力）而导致应用程序变慢，<strong>总吞吐量会降低</strong>。<strong>CMS默认启动的回收线程数是（CPU数量+3）/4</strong>，也就是当CPU在4个或以上时，并发回收时垃圾收集线程占用不超过25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大。如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。</li>
<li><strong>无法处理浮动垃圾</strong>（Floating Garbage） ,可能出现“Concurrent Mode Failure”失败而导致另一次<strong>Full GC</strong>的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</li>
<li><strong>标记-清除算法导致的空间碎片</strong>。CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。</li>
</ul>
<h2 id="garbage-first收集器">Garbage First收集器</h2>
<p>Garbage First(简称G1)收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器<strong>面向局部收集的设计思路</strong>和<strong>基于Region的内存布局形式</strong>。G1是一款主要面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的期望是未来可以替换掉JDK 1.5中发布的CMS收集器。设计师希望建立起“<strong>停顿时间模型</strong>”的收集器，意思是支持在长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。<br>
实现这个目标首先要有一个思想上的转变，对于G1来说，垃圾收集的目标范围不再是新生代、老年代或整个Java堆，它可以面向<strong>堆内存任何部分</strong>来组成回收集(Collection Set)进行回收，衡量标准不再是它属于哪个分代，而是<strong>哪块内存中存放的垃圾数量最多，收益最大</strong>，这就是G1收集器的<strong>Mixed GC</strong>模式。<br>
G1开创的<strong>基于Region的堆内存布局</strong>是它能够实现这个目标的关键。G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域(Region)。每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或是老年代空间。<br>
Region中还有一类用来存储大对象的Humongous区域，G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。Region的大小可以通过参数<code>-XX:G1HeapRegionSize</code>设定，取值范围为1MB～32MB，且应为2的N次幂，默认值为0。超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1603179932644.png" alt="" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mn>1</mn><mi mathvariant="normal">收</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">器</mi><mi>R</mi><mi>e</mi><mi>g</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi mathvariant="normal">分</mi><mi mathvariant="normal">区</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">图</mi></mrow><annotation encoding="application/x-tex">G1收集器Region分区示意图
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">G</span><span class="mord">1</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">器</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">区</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">图</span></span></span></span></span></p>
<p>G1收集器的运作过程大致可划分为以下四个步骤：</p>
<ul>
<li><strong>初始标记</strong>：标记GC Roots能直接关联到的对象，需要Stop The World。</li>
<li><strong>并发标记</strong>：从GC Roots开始对堆中对象进行可达性分析，找出要回收的对象，耗时长，但可与用户程序<strong>并发</strong>执行。</li>
<li><strong>最终标记</strong>：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，需要Stop The World，但可以<strong>并行</strong>执行。</li>
<li><strong>筛选回收</strong>：对各个Region的回收价值和成本进行排序，根据期望的停顿时间制定回收计划，可以自由选择多个Region构成回收集，将决定回收的Region的存活对象复制到空的Region中，清理掉旧Region的全部空间，涉及到存活对象的移动，需要Stop The World，可以<strong>并行</strong>执行。<br>
<strong>G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程，它并非纯粹的追求低延迟，官方给它设定的目标是在延迟可控的情况下获得尽量高的吞吐量，所以才能担当起“全功能收集器”的重任与期望。</strong><br>
<img src="https://MOMENTUMxx.github.io/post-images/1603181221504.jpg" alt="" loading="lazy"></li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mn>1</mn><mi mathvariant="normal">收</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">图</mi></mrow><annotation encoding="application/x-tex">G1收集器运行示意图
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mord">1</span><span class="mord cjk_fallback">收</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">图</span></span></span></span></span></p>
<p>从G1开始，最先进的垃圾收集器的设计导向都不约而同的变为追求能够应付应用的<strong>内存分配速率</strong>(Allocation Rate),而不追求一次把整个Java堆全部清理干净。<br>
<strong>G1收集器与CMS收集器的比较</strong>：<br>
优点：</p>
<ul>
<li>可以指定最大停顿时间</li>
<li>分Region的内存布局</li>
<li>按收益动态确定回收集</li>
<li>整体基于标记-整理算法，局部(两个Region之间)基于标记-复制算法，意味着G1运作期间不会产生内存空间碎片</li>
</ul>
<p>缺点：</p>
<ul>
<li>应用程序运行过程中，G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外负载都要比CMS高</li>
</ul>
<p><strong>依照实践经验，在小内存应用上CMS的表现大概率会优于G1，而在大内存应用上G1则大多能表现更出色，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间。</strong><br>
衡量垃圾收集器的三项最重要的指标是：<strong>内存占用(Footprint)、吞吐量(Throughout)和延迟(Latency)</strong>，三者共同构成了一个“不可能三角”，一款优秀的收集器最多可以同时达成其中的两项。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OutOfMemoryError异常--Java堆溢出]]></title>
        <id>https://MOMENTUMxx.github.io/post/outofmemoryerror-yi-chang-java-dui-yi-chu/</id>
        <link href="https://MOMENTUMxx.github.io/post/outofmemoryerror-yi-chang-java-dui-yi-chu/">
        </link>
        <updated>2020-10-10T11:40:52.000Z</updated>
        <summary type="html"><![CDATA[<p>在Java虚拟机规范的描述中，除了<strong>程序计数器</strong>外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(下文简称OOM)异常的可能，本文简单介绍一下会导致OOM异常出现的Java堆溢出。🍓</p>
]]></summary>
        <content type="html"><![CDATA[<p>在Java虚拟机规范的描述中，除了<strong>程序计数器</strong>外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(下文简称OOM)异常的可能，本文简单介绍一下会导致OOM异常出现的Java堆溢出。🍓</p>
<!-- more -->
<h1 id="java堆溢出">Java堆溢出</h1>
<p>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。<br>
下面的代码限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的<strong>内存堆转储快照</strong>以便事后进行分析。</p>
<pre><code class="language-java">public class HeapOOM {
    static class OOMObject{}
    public static void main(String[] args) {
        List&lt;OOMObject&gt; list = new ArrayList&lt;HeapOOM.OOMObject&gt;();
        while(true) {
            list.add(new OOMObject());
        }
    }
}
</code></pre>
<p>运行结果：<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602330641069.png" alt="" loading="lazy"><br>
Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。<br>
要解决这个区域的异常，一般的手段是先通过<strong>内存映像分析工具</strong>（如Eclipse Memory Analyzer）对Dump出来的<strong>堆转储快照</strong>进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清除到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。下图显示了使用Eclipse Memory Analyzer打开的堆转储快照文件。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602330757091.png" alt="" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">堆</mi><mi mathvariant="normal">转</mi><mi mathvariant="normal">储</mi><mi mathvariant="normal">快</mi><mi mathvariant="normal">照</mi><mi mathvariant="normal">文</mi><mi mathvariant="normal">件</mi></mrow><annotation encoding="application/x-tex">堆转储快照文件
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">堆</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">储</span><span class="mord cjk_fallback">快</span><span class="mord cjk_fallback">照</span><span class="mord cjk_fallback">文</span><span class="mord cjk_fallback">件</span></span></span></span></span></p>
<p>解决方案：<br>
如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的<strong>引用链</strong>。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收他们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确的定位出泄漏代码的位置。<br>
如果不存在泄漏，换句话说，就是内存中的对象确实还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MySQL基础学习笔记]]></title>
        <id>https://MOMENTUMxx.github.io/post/mysql-ji-chu/</id>
        <link href="https://MOMENTUMxx.github.io/post/mysql-ji-chu/">
        </link>
        <updated>2020-10-10T09:49:14.000Z</updated>
        <summary type="html"><![CDATA[<p>整理了一下之前的MySQL笔记，方便随时查漏补缺🍉</p>
]]></summary>
        <content type="html"><![CDATA[<p>整理了一下之前的MySQL笔记，方便随时查漏补缺🍉</p>
<!-- more -->
<h2 id="数据库相关概念">数据库相关概念★</h2>
<ol>
<li>DB： 数据库，保存一组有组织的数据的容器</li>
<li>DBMS：数据库管理系统，用于管理DB中的数据</li>
<li>SQL：结构化查询语言，用于和DBMS通信</li>
</ol>
<h2 id="数据库存储数据的特点">数据库存储数据的特点</h2>
<ol>
<li>将数据放到表中，表再放到库中</li>
<li>一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。</li>
<li>表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。</li>
<li>表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”</li>
<li>表中的数据是按行存储的，每一行类似于java中的“对象”。</li>
</ol>
<h2 id="mysql打开方式">MySQL打开方式</h2>
<ul>
<li>启动：net start mysql</li>
<li>关闭：net stop mysql</li>
</ul>
<h2 id="mysql服务的登录和退出">MySQL服务的登录和退出</h2>
<ul>
<li>通过windows自带的客户端（管理员下的命令行）
<ul>
<li>登录：
<ul>
<li>mysql 【-h 主机名 -P 端口号】 -u 用户名 -p密码</li>
</ul>
</li>
<li>退出：
<ul>
<li>exit或ctrl+c</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="mysql的常见命令">MySQL的常见命令</h2>
<ol>
<li>
<p>查看当前所有的数据库</p>
<p><code>show databases;</code></p>
</li>
<li>
<p>打开指定的库</p>
<p><code>use 库名</code></p>
</li>
<li>
<p>查看当前库的所有表</p>
<p><code>show tables</code></p>
</li>
<li>
<p>查看其他库的所有表</p>
<p><code>show tables from 库名</code></p>
</li>
<li>
<p>创建表</p>
<pre><code class="language-mySQL">create tabel 表名(
	列名 列类型，
 列名 列类型，
    。。。
)
</code></pre>
</li>
<li>
<p>查看表结构</p>
<p><code>desc 表名；</code></p>
</li>
<li>
<p>查看服务器的版本</p>
<p><code>方式一：登录到mysql服务端</code></p>
<p><code>select version();</code></p>
<p><code>方式二：没有登录到mysql服务端</code></p>
<p><code>mysql --version</code></p>
<p><code>或</code></p>
<p><code>mysql --V</code></p>
</li>
</ol>
<h2 id="mysql的语法规范">MySQL的语法规范</h2>
<ol>
<li>
<p>不区分大小写</p>
</li>
<li>
<p>每条命令最好用分号结尾</p>
</li>
<li>
<p>每条命令可以根据需要进行缩进 或换行</p>
</li>
<li>
<p>注释</p>
<p>单行注释：#注释文字</p>
</li>
</ol>
<h2 id="sql的语言分类">SQL的语言分类</h2>
<ul>
<li>DQL（Data Query Language）：数据查询语言
<ul>
<li>select</li>
</ul>
</li>
<li>DML(Data Manipulate Language):数据操作语言
<ul>
<li>insert 、update、delete</li>
</ul>
</li>
<li>DDL（Data Define Languge）：数据定义语言
<ul>
<li>create、drop、alter</li>
</ul>
</li>
<li>TCL（Transaction Control Language）：事务控制语言
<ul>
<li>commit、rollback</li>
</ul>
</li>
</ul>
<h2 id="dql语言">DQL语言</h2>
<h3 id="基础查询">基础查询</h3>
<ul>
<li>语法：select 查询列表 from 表名；</li>
<li>特点：
<ul>
<li>查询列表可以是：表中的字段、常量值、表达式、函数</li>
<li>通过select查询完的结果 ，是一个虚拟的表格，不是真实存在</li>
</ul>
</li>
</ul>
<ol>
<li>查询多个字段时用逗号隔开，最后一个字段不加逗号，语句的最后才加分号</li>
<li>起别名用AS，去重用DISTINCT，拼接用CONCAT(null和任意字符串拼接都为null)</li>
<li>+号的作用：
<ul>
<li>仅有一个功能：运算符</li>
<li>如果两个操作数都为数值型，则做加法运算</li>
<li>只要其中一方为字符型，试图将字符型数值转换成数值型
<ul>
<li>如果转换成功，则继续做加法运算</li>
<li>如果转换失败，则将字符型数值转换成0</li>
</ul>
</li>
<li>只要其中一方为null，则结果肯定为null</li>
</ul>
</li>
</ol>
<h3 id="条件查询">条件查询</h3>
<ul>
<li>语法：select 查询列表 from 表名 where 筛选条件；（执行顺序231）</li>
<li>模糊查询：like（可用通配符：%任意多个字符，包含0个；_任意单个字符），between and（含边界，顺序不能换），in（列表中的值必须一致或兼容），is (not)null</li>
</ul>
<h3 id="排序查询">排序查询</h3>
<ul>
<li>语法：select 要查询的东西 from 表 where 条件 order by 排序的字段|表达式|函数|别名【asc|desc】</li>
<li>特点：默认升序，order by一般放在查询语句的最后(limit语句除外)</li>
</ul>
<h3 id="常见函数">常见函数</h3>
<h4 id="一-单行函数">一、单行函数</h4>
<h5 id="1-字符函数">1、字符函数</h5>
<p>concat,substr,upper,lower,trim,ltrim,rtrim,,replace,lpad,rpad,instr,length(获取字节个数)</p>
<h5 id="2-数学函数">2、数学函数</h5>
<p>round,rand,floor,ceil,mod,truncate(截断)</p>
<h5 id="3-日期函数">3、日期函数</h5>
<p>now,curdate,curtime,str_to_date(将字符转换成日期),date_format(将日期转换成字符)，datediff(返回两个日期相差的天数),monthname(以英文形式返回月)</p>
<h5 id="4-流程控制函数">4、流程控制函数</h5>
<ol>
<li>
<p>if(条件表达式，表达式1，表达式2)</p>
</li>
<li>
<p>case</p>
<ol>
<li>
<pre><code class="language-mySQL">case 变量或表达式或字段
      when 常量1 then 值1
      when 常量2 then 值2
       ...
      else 值a
  end
</code></pre>
</li>
<li>
<pre><code class="language-mySQL">case
      when 条件1 then 值1
      when 条件2 then 值2
        ...
      else 值a
  end
</code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="二-分组函数">二、分组函数</h4>
<p>sum,max,min,avg,count</p>
<ul>
<li>特点：
<ol>
<li>以上五个分组函数都忽略null值，除了count(*)</li>
<li>sum和avg一般用于处理数值型，max、min、count可以处理任何数据类型</li>
<li>都可以搭配distinct使用，用于统计去重后的结果</li>
<li>count(字段):统计该字段非空值的个数；通常用count(*)来计数</li>
<li>和分组函数一同查询的字段必须是分组后的（group by后）</li>
</ol>
</li>
</ul>
<h3 id="分组查询">分组查询</h3>
<ul>
<li>
<p>语法：select 分组函数，分组的字段 from 表 【where 筛选条件】 group by 分组的字段 【having 分组后的筛选】 【order by 排序列表】</p>
</li>
<li>
<p>特点：</p>
<ol>
<li>
<p>分组筛选</p>
<table>
<thead>
<tr>
<th></th>
<th>针对的表</th>
<th>位置</th>
<th style="text-align:center">关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>分组前筛选</td>
<td>原始表</td>
<td>group by的前面</td>
<td style="text-align:center">where</td>
</tr>
<tr>
<td>分组后筛选</td>
<td>分组后的结果集</td>
<td>group by的后面</td>
<td style="text-align:center">having</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>可以按多个字段分组，字段之间用逗号隔开</p>
</li>
<li>
<p>可以支持排序</p>
</li>
<li>
<p>having后可以支持别名</p>
</li>
</ol>
</li>
</ul>
<h3 id="多表连接查询">多表连接查询</h3>
<h4 id="一-含义">一、含义</h4>
<p>​	当查询中涉及到了多个表的字段，需要使用多表连接。</p>
<p>​	<code>select 字段1，字段2</code></p>
<p>​	<code>from 表1，表2...;</code></p>
<h4 id="二-分类">二、分类：</h4>
<ol>
<li>
<p>sql92</p>
<p>等值连接，非等值连接，自连接</p>
</li>
<li>
<p>sql99</p>
<ul>
<li>
<p>内连接：等值，非等值，自连接</p>
</li>
<li>
<p>外连接：左外，右外，全外</p>
</li>
<li>
<p>交叉连接：</p>
</li>
</ul>
</li>
</ol>
<h4 id="三-sql92语法">三、SQL92语法</h4>
<ol>
<li>
<p>等值连接</p>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL"> select 查询列表
from 表1 别名，表2 别名
 where 表1.key=表2.key
【and 筛选条件】
 【group by 分组字段】
【having 分组后的字段】
 【order by 排序字段】
</code></pre>
</li>
<li>
<p>特点：</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>等值连接的结果等于多个表的交集
<ul>
<li>n表连接，至少需要n-1个连接条件</li>
</ul>
</li>
<li>多个表不分主次，没有顺序要求
<ul>
<li>一般为表起别名，起别名后所有位置的表名都要用别名</li>
</ul>
</li>
</ul>
<ol start="2">
<li>
<p>非等值连接</p>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">select 查询列表
from 表1 别名，表2 别名
where 非等值的连接条件
【and 筛选条件】
【group by 分组字段】
【having 分组后的字段】
【order by 排序字段】
</code></pre>
</li>
</ul>
</li>
<li>
<p>自连接</p>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">select 查询列表
from 表 别名1，表 别名2
where 等值的连接条件
【and 筛选条件】
【group by 分组字段】
【having 分组后的字段】
【order by 排序字段】
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="四-sql99语法">四、SQL99语法</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">	select 查询列表
	from 表1 别名 【连接类型】
	join 表2 别名 
	on 连接条件
	【where 筛选条件】
	【group by 分组】
	【having 筛选条件】
	【order by 排序列表】
</code></pre>
</li>
<li>
<p>分类</p>
<ul>
<li>内连接：inner</li>
<li>外连接
<ul>
<li>左外：left outer</li>
<li>右外：right outer</li>
<li>全外：full outer</li>
</ul>
</li>
<li>交叉连接（笛卡尔乘积）</li>
</ul>
</li>
</ul>
<h5 id="1内连接">1）内连接</h5>
<ul>
<li>
<p>语法</p>
<pre><code class="language-mySQL">select 查询列表
from 表1 别名
inner join 表2 别名
on 连接条件
where 筛选条件
group by 分组列表
having 分组后的筛选
order by 排序列表
limit 子句；
</code></pre>
</li>
<li>
<p>分类：等值，非等值，自连接</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>筛选条件放在where后面，连接条件放在on后面，提高分离性</li>
<li>表的顺序可以调换</li>
<li>内连接的结果=多表的交集</li>
<li>n表连接至少需要n-1个连接条件</li>
</ul>
</li>
</ul>
<h5 id="2外连接">2）外连接</h5>
<ul>
<li>
<p>应用场景：用于查询一个表中有，另一个表没有的记录</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">select 查询列表
from 表1 别名
left|right|full join 表2 别名
on 连接条件
where 筛选条件
group by 分组列表
having 分组后的筛选
order by 排序列表
limit 子句
</code></pre>
</li>
<li>
<p>特点：</p>
<ul>
<li>
<p>外连接查询结果=内连接结果+主表有而从表没有的记录</p>
<p>或者说，查询结果=主表中所有的行，如果从表有匹配的将显示匹配行，否则显示null</p>
</li>
<li>
<p>左外连接，left join左边的是主表；右外连接，right join右边的是主表</p>
</li>
<li>
<p>全外连接=内连接+表1中有但表2没有的+表2中有但表1没有的</p>
</li>
</ul>
</li>
<li>
<p>图解：</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://MOMENTUMxx.github.io/post-images/1602325044299.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://MOMENTUMxx.github.io/post-images/1602325053596.png" alt="" loading="lazy"></figure>
<h3 id="子查询">子查询</h3>
<ul>
<li>
<p>含义：出现在其他语句中的select语句称为子查询或内查询；</p>
<p>外部的查询语句（select较多），称为主查询或外查询</p>
</li>
<li>
<p>分类：</p>
<ul>
<li>按子查询出现的位置：
<ul>
<li>select后面：仅支持标量子查询</li>
<li>from后面：支持表子查询</li>
<li>where或having后面：一般用到标量子查询和列子查询</li>
<li>exists后面：表子查询</li>
</ul>
</li>
<li>按结果集的行列数不同：
<ul>
<li>标量子查询：一行一列</li>
<li>列子查询：一列多行</li>
<li>行子查询：一行多列</li>
<li>表子查询：一般多行多列</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="一-where或having后面">一、where或having后面</h4>
<ul>
<li>特点：
<ul>
<li>子查询放在小括号里</li>
<li>标量子查询一般搭配单行操作符使用：&gt; &lt; &gt;= &lt;=  = &lt;&gt;</li>
<li>列子查询一般搭配多行操作符使用：in any/some all</li>
<li>子查询的执行优先于主查询进行，主查询的条件用到了子查询的结果</li>
</ul>
</li>
</ul>
<h4 id="二-select后面">二、select后面</h4>
<ul>
<li>仅仅支持标量子查询</li>
</ul>
<h4 id="三-from后面">三、from后面</h4>
<ul>
<li>将子查询结果充当一张表，要求必须起别名</li>
</ul>
<h3 id="分页查询">分页查询</h3>
<ul>
<li>
<p>应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">select 查询列表
from 表
【join type join 表2
on 连接条件
where 筛选条件
group by 分组字段
having 分组后的筛选
order by 排序的字段】
limit 【offset,】size;
</code></pre>
<p>offset为要显示条目的起始索引（从0开始，默认为0）</p>
<p>size为要显示的条目个数</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>
<p>limit语句放在查询语句的最后</p>
</li>
<li>
<p>公式：</p>
<ul>
<li>
<p>要显示的页数 page，每页的条目数size</p>
<pre><code class="language-mySQL">select 查询列表
from 表
limit (page-1)*size,size;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="联合查询">联合查询</h3>
<ul>
<li>
<p>含义：将多条查询语句的结果合并成一个结果</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">查询语句1
union
查询语句2
union
...
</code></pre>
</li>
<li>
<p>应用场景：要查询的结果来自多个表，且多个表没有直接的连接关系，但查询的信息一致时</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>要求多条查询语句的查询列数是一致的</li>
<li>要求多条查询语句查询的每一列的类型和顺序最好一致</li>
<li>union关键字默认去重，如果使用union all可以包含重复项</li>
</ul>
</li>
</ul>
<h3 id="dql语言执行顺序总结">DQL语言执行顺序总结</h3>
<blockquote>
<pre><code class="language-mySQL">select 查询列表			7
from 表             	  1
连接类型 join 表2	   2 
on 连接条件				3
where 筛选条件          4
group by 分组列表       5
having 分组后的筛选      6
order by 排序列表       8
limit 起始索引，条目数   9	
</code></pre>
</blockquote>
<h2 id="dml语言">DML语言</h2>
<p>​		插入：insert</p>
<p>​		修改：update</p>
<p>​		删除：delete</p>
<h3 id="一-插入语句">一、插入语句</h3>
<h4 id="方式一经典的插入">方式一：经典的插入</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">insert into 表名(列名,...) values(值,...),values(值,...),...;
</code></pre>
</li>
<li>
<p>特点：</p>
<ul>
<li>插入的值的类型要与列的类型一致或兼容</li>
<li>不可以为null的列必须插入值，可以为null的列能够通过两种方式插入null值
<ul>
<li>字段和值都省略</li>
<li>写字段，值使用null</li>
</ul>
</li>
<li>列的顺序可以调换</li>
<li>列数和值的个数必须一致</li>
<li>可以省略列名，默认为所有列，而且的列的顺序和表中列的顺序一致</li>
</ul>
</li>
</ul>
<h4 id="方式二">方式二</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">insert into 表名
set 列名=值，列名=值...
</code></pre>
</li>
</ul>
<h4 id="两种方式的比较">两种方式的比较</h4>
<ol>
<li>
<p>方式一支持插入多行，方式二不支持</p>
</li>
<li>
<p>方式一支持子查询，方式二不支持</p>
<p>如：</p>
<pre><code class="language-mySQL">INSERT INTO beauty(id,NAME,phone)
SELECT id,boyname,'1234567'
FROM boys WHERE id&lt;3;
</code></pre>
</li>
</ol>
<h3 id="二-修改语句">二、修改语句</h3>
<h4 id="1-修改单表的记录">1. 修改单表的记录★</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">update 表名
set 列=新值，列=新值...
where 筛选条件；
</code></pre>
</li>
</ul>
<h4 id="2-修改多表的记录">2. 修改多表的记录</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">update 表1 别名
inner|left|right join 表2 别名
on 连接条件
set 列=值,...
where 筛选条件;
</code></pre>
</li>
</ul>
<h3 id="三-删除语句">三、删除语句</h3>
<h4 id="方式一delete">方式一：delete</h4>
<ul>
<li>
<p>语法：</p>
<ol>
<li>
<p>单表的删除★</p>
<pre><code class="language-mySQL">delete from 表名 where 筛选条件【limit 条目数】；
</code></pre>
</li>
<li>
<p>多表的删除</p>
<pre><code class="language-mySQL">delete 表1的别名,表2的别名
from 表1 别名
inner|left|right join 表2 别名
on 连接条件
where 筛选条件；
</code></pre>
</li>
</ol>
</li>
</ul>
<h4 id="方式二truncate">方式二：truncate</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">truncate table 表名；
</code></pre>
</li>
</ul>
<h4 id="delete和truncate比较">delete和truncate比较★</h4>
<ol>
<li>delete可以加筛选条件，truncate不能加</li>
<li>truncate效率略高一点</li>
<li>加入要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始</li>
<li>truncate删除没有返回值，delete删除有返回值</li>
<li>truncate删除不能回滚，delete删除可以回滚</li>
</ol>
<h2 id="ddl语言">DDL语言</h2>
<p>​		创建：create</p>
<p>​		修改：alter</p>
<p>​		删除：drop</p>
<h3 id="一-库的管理">一、库的管理</h3>
<h4 id="1-库的创建">1. 库的创建</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">create database 【if not exists】 库名;
</code></pre>
</li>
</ul>
<h4 id="2-库的修改">2. 库的修改</h4>
<ul>
<li>
<p>更改库的字符集</p>
<pre><code class="language-mySQL">alter database 库名 character set 字符集名;
</code></pre>
</li>
</ul>
<h4 id="3-库的删除">3. 库的删除</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">drop database if exists 库名;
</code></pre>
</li>
</ul>
<h3 id="二-表的管理">二、表的管理</h3>
<h4 id="1-表的创建">1. 表的创建★</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">create table 表名(
	列名 列的类型【(长度) 约束】,
	列名 列的类型【(长度) 约束】,
	列名 列的类型【(长度) 约束】,
	...
	列名 列的类型【(长度) 约束】
)
</code></pre>
</li>
</ul>
<h4 id="2-表的修改">2. 表的修改</h4>
<ol>
<li>
<p>添加列：</p>
<pre><code class="language-mySQL">alter table 表名 add column 列名 类型 【first|alter 字段名】;
</code></pre>
</li>
<li>
<p>修改列的类型或约束</p>
<pre><code class="language-mySQL">alter table 表名 modify column 列名 新类型 【新约束】;
</code></pre>
</li>
<li>
<p>修改列名</p>
<pre><code class="language-mySQL">alter table 表名 change column 旧列名 新列名 类型;
</code></pre>
</li>
<li>
<p>删除列</p>
<pre><code class="language-mySQL">alter table 表名 drop column 列名;
</code></pre>
</li>
<li>
<p>修改表名</p>
<pre><code class="language-mySQL">alter table 表名 rename 【to】 新表名;
</code></pre>
</li>
</ol>
<h4 id="3-表的删除">3. 表的删除</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">drop table 【if exists】 表名;
</code></pre>
</li>
</ul>
<h4 id="4-表的复制">4. 表的复制</h4>
<ol>
<li>
<p>仅仅复制表的结构</p>
<pre><code class="language-mySQL">create table 新表 like 旧表;
</code></pre>
</li>
<li>
<p>复制表的结构+数据</p>
<ul>
<li>
<p>全部数据</p>
<pre><code class="language-mySQL">create table 新表
select * from 旧表;
</code></pre>
</li>
<li>
<p>部分数据</p>
<pre><code class="language-mySQL">create table 新表
select 字段1,字段2... 
from 旧表
where 筛选条件;
</code></pre>
</li>
<li>
<p>仅仅复制某些字段</p>
<pre><code class="language-mySQL">create table 新表
select 字段1,字段2... 
from 旧表
where 0; 
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="常见的数据类型">常见的数据类型</h3>
<h4 id="一-数值型">一、数值型</h4>
<ol>
<li>整形</li>
</ol>
<ul>
<li>
<p>分类：tinyint(1),smallint(2),mediumint(3),int/integer(4),bigint(8)</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>如果不设置无符号还是有符号，默认是有符号，设置无符号要添加关键字unsigned</li>
<li>如果插入的数值超出了整型的范围，会报out of range异常，并且插入临界值</li>
<li>如果不设置长度，会有默认的长度（长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用）</li>
</ul>
</li>
</ul>
<ol start="2">
<li>浮点型</li>
</ol>
<ul>
<li>
<p>分类：</p>
<ul>
<li>浮点型：float(M,D),double(M,D)</li>
<li>定点型：decimal(M,D)</li>
</ul>
</li>
<li>
<p>特点：</p>
<ul>
<li>
<p>M：整数部位+小数部位的个数</p>
<p>D：小数部位的个数</p>
<p>如果超过范围，则插入临界值</p>
</li>
<li>
<p>M和D都可以省略</p>
<p>如果是decimal，则M默认为10，D默认为0</p>
<p>如果是float和double，则会根据插入的数值的精度来决定精度</p>
</li>
<li>
<p>定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</p>
</li>
</ul>
</li>
<li>
<p>原则：</p>
<p>所选择的类型越简单越好，能保存数值的类型越小越好</p>
</li>
</ul>
<h4 id="二-字符型">二、字符型</h4>
<ul>
<li>
<p>较短的文本：char和varchar</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th>写法</th>
<th>M的意思</th>
<th>特点</th>
<th>空间的耗费</th>
<th>效率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">char</td>
<td>char(M)</td>
<td>最大的字符数</td>
<td>可以省略，默认为1，长度固定</td>
<td>比较耗费</td>
<td>高</td>
</tr>
<tr>
<td style="text-align:center">varchar</td>
<td>varchar(M)</td>
<td>最大的字符数</td>
<td>不可以省略，长度可变</td>
<td>比较节省</td>
<td>低</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>较长的文本：text，blob（较大的二进制）</p>
</li>
<li>
<p>其他：binary和varbinary用于保存较短的二进制</p>
<p>​			enum用于保存枚举</p>
<p>​			set用于保存集合</p>
</li>
</ul>
<h4 id="三-日期型">三、日期型</h4>
<ul>
<li>
<p>分类：date,time,year,datetime,timestamp</p>
</li>
<li>
<p>特点：</p>
<table>
<thead>
<tr>
<th></th>
<th>字节</th>
<th>范围</th>
<th style="text-align:center">时区等的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>datetime</td>
<td>8</td>
<td>1000-9999</td>
<td style="text-align:center">不受</td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>1970-2038</td>
<td style="text-align:center">受</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="常见约束">常见约束</h3>
<ul>
<li>含义：一种限制，用于限制表中的数据，为了保证表中数据的准确和可靠性</li>
<li>分类：六大约束
<ul>
<li>NOT NULL:非空，用于保证该字段的值不能为空</li>
<li>DEFAULT:默认，用于保证该字段有默认值</li>
<li>PRIMARY KEY:主键，用于保证该字段的值具有唯一性，并且非空</li>
<li>UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为null</li>
<li>CHECK:检查约束【mysql不支持】</li>
<li>FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自主表的关联列的值。在从表添加外键约束，用于引用主表中某列的值</li>
</ul>
</li>
<li>添加约束的时机：
<ol>
<li>创建表时</li>
<li>修改表时</li>
</ol>
</li>
<li>约束的添加分类：
<ul>
<li>列级约束：六大约束语法上都支持，但外键约束没有效果</li>
<li>表级约束：除了NOT NULL和DEFAULT其他都支持</li>
</ul>
</li>
</ul>
<h4 id="一-创建表时添加约束">一、创建表时添加约束</h4>
<ol>
<li>添加列级约束</li>
</ol>
<ul>
<li>语法:直接在字段名和类型后面追加约束类型即可，只支持：默认、非空、主键、唯一
<ul>
<li>列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求</li>
</ul>
</li>
</ul>
<ol start="2">
<li>
<p>添加表级约束</p>
<ul>
<li>
<p>语法：在各个字段的最下面</p>
<p>【constraint 约束名】 约束类型(字段名)</p>
</li>
</ul>
</li>
<li>
<p>通用写法示例</p>
<pre><code class="language-mySQL">CREATE TABLE stuinfo(
	字段名 字段类型 PRIMARY KEY,
	字段名 字段类型 NOT NULL,
	字段名 字段类型 UNIQUE,
	字段名 字段类型 DEFAULT 值,
	CONSTRAINT 约束名 FOREIGN KEY(字段名) REFERENCES 主表(被引用列)
);
</code></pre>
</li>
</ol>
<ul>
<li>
<p>主键和唯一的比较</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">保证唯一性</th>
<th style="text-align:center">是否允许为空</th>
<th style="text-align:center">一个表中可以有多少个</th>
<th style="text-align:center">是否允许组合</th>
</tr>
</thead>
<tbody>
<tr>
<td>主键</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">至多有一个</td>
<td style="text-align:center">√（不推荐）</td>
</tr>
<tr>
<td>唯一</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">可以有多个</td>
<td style="text-align:center">√（不推荐）</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>外键：</p>
<ul>
<li>
<p>要求在从表设置外键关系</p>
</li>
<li>
<p>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</p>
</li>
<li>
<p>主表的关联列必须是一个key（一般是主键或唯一）</p>
</li>
<li>
<p>插入数据时，先插入主表，再插入从表；</p>
<p>删除数据时，先删除从表，在删除主表</p>
</li>
<li>
<p>级联删除：设置外键时追加ON DELETE CASCADE</p>
<p>级联置空：设置外键时追加ON DELETE SET NULL</p>
<p>这两种删除方式不受上一点的约束</p>
</li>
</ul>
</li>
</ul>
<h4 id="二-修改表时添加删除约束">二、修改表时添加/删除约束</h4>
<ol>
<li>
<p>非空</p>
<ul>
<li>
<p>添加非空</p>
<pre><code class="language-mySQL">alter table 表名 modify column 字段名 字段类型 not null;
</code></pre>
</li>
<li>
<p>删除非空</p>
<pre><code class="language-mySQL">alter table 表名 modify column 字段名 字段类型;
</code></pre>
</li>
</ul>
</li>
<li>
<p>默认</p>
<ul>
<li>
<p>添加默认</p>
<pre><code class="language-mySQL">alter table 表名 modify column 字段名 字段类型 default 值;
</code></pre>
</li>
<li>
<p>删除默认</p>
<pre><code class="language-mySQL">alter table 表名 modify column 字段名 字段类型;
</code></pre>
</li>
</ul>
</li>
<li>
<p>主键</p>
<ul>
<li>
<p>添加主键</p>
<pre><code class="language-mySQL">alter table 表名 add【constraint 约束名】primary key(字段名);
</code></pre>
</li>
<li>
<p>删除主键</p>
<pre><code class="language-mySQL">alter table 表名 drop primary key;
</code></pre>
</li>
</ul>
</li>
<li>
<p>唯一</p>
<ul>
<li>
<p>添加唯一</p>
<pre><code class="language-mySQL">alter table 表名 add【constraint 约束名】unique(字段名);
</code></pre>
</li>
<li>
<p>删除唯一</p>
<pre><code class="language-mySQL">alter table 表名 drop index 索引名;
</code></pre>
</li>
</ul>
</li>
<li>
<p>外键</p>
<ul>
<li>
<p>添加外键</p>
<pre><code class="language-mySQL">alter table 表名 add【constraint 约束名】foreign key(字段名) references 主表(被引用列);
</code></pre>
</li>
<li>
<p>删除外键</p>
<pre><code class="language-mySQL">alter table 表名 drop foreign key 约束名;
</code></pre>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>列级约束和表级约束比较</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">位置</th>
<th style="text-align:center">支持的约束类型</th>
<th style="text-align:center">是否可以起约束名</th>
</tr>
</thead>
<tbody>
<tr>
<td>列级约束</td>
<td style="text-align:center">列的后面</td>
<td style="text-align:center">语法都支持，但外键没有效果</td>
<td style="text-align:center">不可以</td>
</tr>
<tr>
<td>表级约束</td>
<td style="text-align:center">所有列的下面</td>
<td style="text-align:center">默认和非空不支持，其他支持</td>
<td style="text-align:center">可以（主键没有效果）</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="标识列自增长列">标识列（自增长列）</h3>
<ul>
<li>含义：可以不用手动的插入值，系统提供默认的序列</li>
<li>特点：
<ul>
<li>默认从1开始，步长为1</li>
<li>标识列必须和一个key（主键，唯一，外键）搭配</li>
<li>一个表中至多有一个标识列</li>
<li>标识列的类型只能是数值型</li>
</ul>
</li>
</ul>
<h4 id="一-创建表时设置标识列">一、创建表时设置标识列</h4>
<pre><code class="language-mySQL">create table 表名(
	字段名 字段类型 约束条件 AUTO_INCREMENT,
	...
);
</code></pre>
<h4 id="二-修改表时设置标识列">二、修改表时设置标识列</h4>
<pre><code class="language-mySQL">alter table 表名 modify column 字段名 字段类型 约束条件 AUTO_INCREMENT;
</code></pre>
<h4 id="三-修改表时删除标识列">三、修改表时删除标识列</h4>
<pre><code class="language-mySQL">alter table 表名 modify column 字段名 字段类型 约束条件;
</code></pre>
<h2 id="tcl语言">TCL语言</h2>
<h3 id="事务">事务</h3>
<p>​		事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事务开始以前的状态；如果单元中的所有SQL语句均执行成功，则事务被顺利执行。</p>
<h4 id="事务的acid属性">事务的ACID属性</h4>
<ol>
<li>原子性(Atomicity):事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生</li>
<li>一致性(Consistency):事务必须使数据库从一个一致性状态变换到另一个一致性状态</li>
<li>隔离性(Isolation):一个事务的执行不能被其他事务干扰</li>
<li>持久性(Durability):一个事务一旦被提交，它对数据库中数据的改变就是永久性的</li>
</ol>
<h4 id="事务的创建">事务的创建★</h4>
<ul>
<li>
<p>隐式事务：事务没有明显的开启和结束的标记；比如insert,update,delete</p>
</li>
<li>
<p>显式事务：事务具有明显的开启和结束的标记；前提：必须先设置自动提交功能为禁用</p>
<ul>
<li>
<p>步骤1：开启事务</p>
<pre><code class="language-mySQL">set autocommit=0;
start transaction;（可选的）
</code></pre>
</li>
<li>
<p>步骤2：编写事务中的sql语句(select,insert,update,delete)</p>
<pre><code class="language-mySQL">语句1，
语句2，
savepoint 节点名;（设置保存点）
......
</code></pre>
</li>
<li>
<p>步骤3：结束事务</p>
<pre><code class="language-mySQL">commit;（提交事务）
rollback;（回滚事务）
rollback to 回滚点名;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="并发事务">并发事务</h4>
<ol>
<li>
<p>事务的并发问题是如何发生的？</p>
<p>多个事务同时操作同一个数据库的相同数据</p>
</li>
<li>
<p>并发问题有哪些？</p>
<ul>
<li>脏读：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据</li>
<li>不可重复读：一个事务多次读取，结果不一样</li>
<li>幻读：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“插入”的数据</li>
</ul>
</li>
<li>
<p>如何解决并发问题？</p>
<p>设置隔离级别</p>
</li>
</ol>
<h4 id="事务的隔离级别">事务的隔离级别</h4>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>read uncommitted（读未提交）</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>read committed（读已提交）</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>repeatable read（可重复读）</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>serializable（串行化）</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>mysql中默认隔离级别是repeatable read</p>
</li>
<li>
<p>查看隔离级别的命令：</p>
<pre><code class="language-mySQL">select @@tx_isolation;
</code></pre>
</li>
<li>
<p>设置隔离级别的命令：</p>
<pre><code class="language-mySQL">set session|global transaction isolation level 隔离级别;
</code></pre>
</li>
</ul>
<h3 id="视图">视图</h3>
<ul>
<li>含义：虚拟表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果。</li>
<li>应用场景：多个地方用到同样的查询结果，该查询结果使用的sql语句较复杂</li>
<li>好处：
<ul>
<li>简化sql语句</li>
<li>提高了sql的重用性</li>
<li>保护基表的数据，提高了安全性</li>
</ul>
</li>
</ul>
<h4 id="一-创建视图">一、创建视图</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">create view 视图名
as
查询语句;
</code></pre>
</li>
</ul>
<h4 id="二-视图的修改">二、视图的修改</h4>
<ul>
<li>
<p>方式一：</p>
<pre><code class="language-mySQL">create or replace view 视图名
as
查询语句;
</code></pre>
</li>
<li>
<p>方式二：</p>
<pre><code class="language-mySQL">alter view 视图名
as
查询语句;
</code></pre>
</li>
</ul>
<h4 id="三-删除视图">三、删除视图</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">drop view 视图名,视图名,...;
</code></pre>
</li>
</ul>
<h4 id="四-查看视图">四、查看视图</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">desc 视图名;
或
show create view 视图名;
</code></pre>
</li>
</ul>
<h4 id="五-视图的更新">五、视图的更新</h4>
<p>与表类似，<strong>但视图一般用于查询</strong>，而不是更新，所以具备以下特点的视图都不允许更新：</p>
<ol>
<li>包含分组函数、group by、distinct、having、union</li>
<li>join</li>
<li>常量视图</li>
<li>where后的子查询用到了from中的表</li>
<li>用到了不可更新的视图</li>
</ol>
<h4 id="六-视图和表的对比">六、视图和表的对比</h4>
<table>
<thead>
<tr>
<th></th>
<th>创建语法的关键字</th>
<th>保存的内容</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>视图</td>
<td>create view</td>
<td>sql逻辑</td>
<td>增删改查（一般只查）</td>
</tr>
<tr>
<td>表</td>
<td>create table</td>
<td>实际数据</td>
<td>增删改查</td>
</tr>
</tbody>
</table>
<h2 id="变量">变量</h2>
<ul>
<li>系统变量
<ul>
<li>全局变量</li>
<li>会话变量</li>
</ul>
</li>
<li>自定义变量
<ul>
<li>用户变量</li>
<li>局部变量</li>
</ul>
</li>
</ul>
<h3 id="一-系统变量">一、系统变量</h3>
<ul>
<li>
<p>说明：变量由系统提供，不是用户定义，属于服务器层面</p>
</li>
<li>
<p>语法：</p>
<ol>
<li>
<p>查看所有的系统变量</p>
<pre><code class="language-mySQL">show global|【session】 variables;
</code></pre>
</li>
<li>
<p>查看满足条件的部分系统变量</p>
<pre><code class="language-mySQL">show global|【session】 variables like '%char%';
</code></pre>
</li>
<li>
<p>查看指定的某个系统变量的值</p>
<pre><code class="language-mySQL">select @@global|【session】.系统变量名;
</code></pre>
</li>
<li>
<p>为某个系统变量赋值</p>
<p>方式一：</p>
<pre><code class="language-mySQL">set global|【session】 系统变量名=值；
</code></pre>
<p>方式二：</p>
<pre><code class="language-mySQL">set @@global|【session】.系统变量名=值;
</code></pre>
</li>
</ol>
</li>
<li>
<p>注意：如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认session</p>
</li>
</ul>
<h4 id="1-全局变量">1. 全局变量</h4>
<ul>
<li>作用域：服务器每次启动将为所有的全局变量赋初始值，针对于所有的会话（连接）有效，但不能跨重启</li>
</ul>
<h4 id="2-会话变量">2. 会话变量</h4>
<ul>
<li>作用域：仅仅针对当前会话（连接）有效，应用在任何地方，也就是begin end里面外面均可</li>
</ul>
<h3 id="二-自定义变量">二、自定义变量</h3>
<ul>
<li>说明：变量是用户自定义的，不是由系统提供</li>
<li>使用步骤：声明，赋值，使用（查看、比较、运算等）</li>
</ul>
<h4 id="1-用户变量">1. 用户变量</h4>
<ul>
<li>作用域：针对于当前会话（连接）有效</li>
<li>位置：可以放在begin end里面或外面</li>
</ul>
<ol>
<li>
<p>声明并初始化，赋值的操作符：=或:=</p>
<pre><code class="language-mySQL">set @用户变量名=值;
或
set @用户变量名:=值;
或
select @用户变量名:=值;
</code></pre>
</li>
<li>
<p>赋值（更新用户变量的值）</p>
<p>方式一：通过set或select</p>
<pre><code class="language-mySQL">set @用户变量名=值;
或
set @用户变量名:=值;
或
select @用户变量名:=值;
</code></pre>
<p>方式二：通过select into</p>
<pre><code class="language-mySQL">select 字段 into @变量名
from 表;
</code></pre>
</li>
<li>
<p>使用（查看）</p>
<pre><code class="language-mySQL">select @用户变量名;
</code></pre>
</li>
</ol>
<h4 id="2-局部变量">2. 局部变量</h4>
<ul>
<li>作用域：仅仅在定义它的begin end中有效，应用在begin end中的第一句话！！</li>
</ul>
<ol>
<li>
<p>声明</p>
<pre><code class="language-mySQL">declare 变量名 类型;
或
declare 变量名 类型 default 值;
</code></pre>
</li>
<li>
<p>赋值</p>
<p>方式一：通过set或select</p>
<pre><code class="language-mySQL">set 局部变量名=值;
或
set 局部变量名:=值;
或
select @局部变量名:=值;
</code></pre>
<p>方式二：通过select into</p>
<pre><code class="language-mySQL">select 字段 into 局部变量名
from 表;
</code></pre>
</li>
<li>
<p>使用</p>
<pre><code class="language-mySQL">select 局部变量名;
</code></pre>
</li>
</ol>
<h4 id="3-对比用户变量和局部变量">3. 对比用户变量和局部变量</h4>
<table>
<thead>
<tr>
<th></th>
<th>作用域</th>
<th>定义和使用的位置</th>
<th>语法</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户变量</td>
<td>当前会话</td>
<td>会话中的任何地方</td>
<td>必须加@，不用限定类型</td>
</tr>
<tr>
<td>局部变量</td>
<td>begin end中</td>
<td>只能在begin end中，且为第一句话</td>
<td>除select外一般不用加@，需要限定类型</td>
</tr>
</tbody>
</table>
<h2 id="存储过程和函数">存储过程和函数</h2>
<p>存储过程和函数的结尾可以使用delimiter重新设置</p>
<p>语法：</p>
<pre><code class="language-mySQL">demiliter 结束标记
</code></pre>
<p>设置完成后end后面和每次调用存储过程和函数的结尾都要加上结束标记</p>
<h3 id="存储过程">存储过程</h3>
<ul>
<li>含义：一组预先编译好的SQL语句的集合，理解成批处理语句</li>
<li>好处：
<ul>
<li>提高代码的重用性</li>
<li>简化操作</li>
<li>减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</li>
</ul>
</li>
</ul>
<h4 id="一-创建语法">一、创建语法★</h4>
<pre><code class="language-mySQL">create procedure 存储过程名(参数列表)
begin
	存储过程体（一组合法的SQL语句）
end
</code></pre>
<ul>
<li>
<p>注意</p>
<ol>
<li>
<p>参数列表包含三部分：参数模式，参数名，参数类型</p>
<p>参数模式：</p>
<p>IN：该参数可以作为输入，需要调用方传入值</p>
<p>OUT：该参数可以作为输出，也就是可以作为返回值</p>
<p>INOUT：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值</p>
</li>
<li>
<p>如果存储过程体只有一句话，begin end可以省略</p>
</li>
<li>
<p>存储过程体中的每条SQL语句的结尾要求必须加分号</p>
</li>
</ol>
</li>
</ul>
<h4 id="二-调用语法">二、调用语法</h4>
<ul>
<li>
<p>调用in模式的参数：</p>
<pre><code class="language-mySQL">call 存储过程名('值');
</code></pre>
</li>
<li>
<p>调用out模式的参数：</p>
<pre><code class="language-mySQL">set @变量名;
call 存储过程名(@变量名);
select @变量名;
</code></pre>
</li>
<li>
<p>调用inout模式的参数：</p>
<pre><code class="language-mySQL">set @变量名=值;
call 存储过程名(@变量名);
select @变量名;
</code></pre>
</li>
</ul>
<h4 id="三-删除存储过程">三、删除存储过程</h4>
<pre><code class="language-mySQL">drop procedure 存储过程名;
</code></pre>
<h4 id="四-查看存储过程的信息">四、查看存储过程的信息</h4>
<pre><code class="language-mySQL">show create procedure 存储过程名;
</code></pre>
<h3 id="函数">函数</h3>
<ul>
<li>与存储过程的区别
<ul>
<li>存储过程可以有0个或多个返回，适合批量插入、批量更新</li>
<li>函数有且仅有1个返回，适合处理数据后返回一个结果</li>
</ul>
</li>
</ul>
<h4 id="一-创建语法-2">一、创建语法</h4>
<pre><code class="language-mySQL">create function 函数名(参数列表) returns 返回类型
begin
	函数体
end
</code></pre>
<ul>
<li>注意
<ol>
<li>参数列表包含两部分：参数名 参数类型</li>
<li>函数体：肯定有return语句，一般放在函数体最后</li>
<li>如果函数体中只有一句话，则可以省略begin end</li>
<li>使用delimiter语句设置结束标记</li>
</ol>
</li>
</ul>
<h4 id="二-调用语法-2">二、调用语法</h4>
<pre><code class="language-mySQL">select 函数名(实参列表);
</code></pre>
<h4 id="三-查看函数">三、查看函数</h4>
<pre><code class="language-mySQL">show create function 函数名;
</code></pre>
<h4 id="四-删除函数">四、删除函数</h4>
<pre><code class="language-mySQL">drop function 函数名;
</code></pre>
<h2 id="流程控制结构">流程控制结构</h2>
<h3 id="一-分支结构">一、分支结构</h3>
<h4 id="1-if函数">1. if函数</h4>
<ul>
<li>
<p>功能：简单实现的双分支</p>
</li>
<li>
<p>位置：可以作为表达式放在begin end里面或外面</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">if(表达式1,表达式2,表达式3)
执行顺序：如果表达式1成立则if函数返回表达式2的值，否则返回表达式3的值
</code></pre>
</li>
</ul>
<h4 id="2-case结构">2、case结构</h4>
<p>情况1：类似于Java中的switch语句，一般用于实现等值判断</p>
<ul>
<li>
<p>语法：</p>
<ul>
<li>
<p>作为表达式</p>
<pre><code class="language-mySQL">case 变量|表达式|字段
when 要判断的值 then 返回的值1
when 要判断的值 then 返回的值2
...
else 要返回的值n
end;
</code></pre>
</li>
<li>
<p>作为独立的语句</p>
<pre><code class="language-mySQL">case 变量|表达式|字段
when 要判断的值 then 返回的语句1;
when 要判断的值 then 返回的语句2;
...
else 要返回的语句n;
end case;
</code></pre>
</li>
</ul>
</li>
</ul>
<p>情况2：类似于Java中的多重if语句，一般用于实现区间判断</p>
<ul>
<li>
<p>语法：</p>
<ul>
<li>
<p>作为表达式</p>
<pre><code class="language-mySQL">case
when 要判断的条件1 then 返回的值1
when 要判断的条件2 then 返回的值2
...
else 要返回的值n
end;
</code></pre>
</li>
<li>
<p>作为独立的语句</p>
<pre><code class="language-mySQL">case
when 要判断的条件1 then 返回的语句1;
when 要判断的条件2 then 返回的语句2;
...
else 要返回的语句n;
end case;
</code></pre>
</li>
</ul>
</li>
</ul>
<p>特点：</p>
<ol>
<li>
<p>可以作为表达式，嵌套在其他语句中使用，此时可以放在任何地方，begin end中或begin end的外面；</p>
<p>可以作为独立的语句去使用，此时只能放在begin end中</p>
</li>
<li>
<p>如果when中的值满足或条件成立，则执行对应的then后面的语句，并且结束case；</p>
<p>如果都不满足，则执行else中的语句或值</p>
</li>
<li>
<p>else可以省略，如果省略else并且所有的when条件都不满足，则返回null</p>
</li>
</ol>
<h4 id="3-if结构">3. if结构</h4>
<ul>
<li>
<p>功能：实现多重分支</p>
</li>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">if 条件1 then 语句1;
elseif 条件2 then 语句2;
...
【else 语句n;】
end if;
</code></pre>
</li>
<li>
<p>特点：只能用在begin end中</p>
</li>
</ul>
<h3 id="二-循环结构">二、循环结构</h3>
<ul>
<li>分类：while,loop,repeat</li>
<li>位置：只能放在begin end中</li>
<li>循环控制：
<ul>
<li>iterate：类似于continue，结束本次循环，继续下一次</li>
<li>leave：类似于break，结束当前所在的循环</li>
</ul>
</li>
<li>三种循环都可以省略名称，但如果循环中添加了循环控制语句（leave或iterate）则必须添加名称</li>
</ul>
<h4 id="1-while">1. while</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">【标签:】while 循环条件 do
		循环体;
end while【标签】;
</code></pre>
</li>
<li>
<p>特点：先判断后执行</p>
</li>
</ul>
<h4 id="2-loop">2. loop</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">【标签:】loop
		循环体;
end loop【标签】;
</code></pre>
<p>可以用来实现简单的死循环</p>
</li>
</ul>
<h4 id="3-repeat">3. repeat</h4>
<ul>
<li>
<p>语法：</p>
<pre><code class="language-mySQL">【标签:】repeat
		循环体;
until 结束循环的条件
end repeat【标签】;
</code></pre>
</li>
<li>
<p>特点：先执行后判断，无条件至少执行一次</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java内存模型及分区]]></title>
        <id>https://MOMENTUMxx.github.io/post/java-nei-cun-mo-xing-ji-fen-qu/</id>
        <link href="https://MOMENTUMxx.github.io/post/java-nei-cun-mo-xing-ji-fen-qu/">
        </link>
        <updated>2020-10-08T09:45:36.000Z</updated>
        <summary type="html"><![CDATA[<p>🎧Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人想出来。</p>
]]></summary>
        <content type="html"><![CDATA[<p>🎧Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人想出来。</p>
<!-- more -->
<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，如图所示。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602150845291.png" alt="Java虚拟机运行时数据区" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi>a</mi><mi>v</mi><mi>a</mi><mi mathvariant="normal">虚</mi><mi mathvariant="normal">拟</mi><mi mathvariant="normal">机</mi><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">区</mi></mrow><annotation encoding="application/x-tex">Java虚拟机运行时数据区
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">虚</span><span class="mord cjk_fallback">拟</span><span class="mord cjk_fallback">机</span><span class="mord cjk_fallback">运</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">区</span></span></span></span></span></p>
<p>这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p>
<h1 id="程序计数器">程序计数器</h1>
<p>程序计数器可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等基础功能都需要依赖这个计数器来完成。<br>
由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，<strong>每条线程都需要有一个独立的程序计数器</strong>，各条线程之间计数器互不影响，独立存储，为<strong>线程私有</strong>的内存。<br>
如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。<br>
<strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></p>
<h1 id="java虚拟机栈">Java虚拟机栈</h1>
<p>Java虚拟机栈是<strong>线程私有</strong>的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的时候都会同时创建一个栈帧用于<strong>存储局部变量表、操作栈、动态连接、方法出口</strong>等信息。每一个方法从被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程，如下图所示。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602157809259.png" alt="" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi>a</mi><mi>v</mi><mi>a</mi><mi mathvariant="normal">虚</mi><mi mathvariant="normal">拟</mi><mi mathvariant="normal">机</mi><mi mathvariant="normal">栈</mi></mrow><annotation encoding="application/x-tex">Java虚拟机栈
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">虚</span><span class="mord cjk_fallback">拟</span><span class="mord cjk_fallback">机</span><span class="mord cjk_fallback">栈</span></span></span></span></span></p>
<p><strong>局部变量表</strong>用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>，其大小在代码编译期间已经确定，在方法运行期间不会改变。局部变量表以<strong>变量槽</strong>（Slot）为最小存储单位，每个Slot能够存放基本数据类型（boolean、byte、char、short、int、long、float、double）、对象引用（reference类型）或是returnAddress类型（指向了一条字节码指令的地址）。<br>
在《Java虚拟机规范》中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowError</code>异常；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存时会抛出<code>OutOfMemoryError</code>异常。</p>
<h1 id="本地方法栈">本地方法栈</h1>
<p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则<strong>为虚拟机使用到的Native方法服务</strong>。<br>
与虚拟机栈一样，本地方法栈区域也会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</p>
<h1 id="java堆">Java堆</h1>
<p>Java堆是<strong>被所有线程共享</strong>的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是<strong>存放对象实例</strong>，所有的对象实例以及数组都要在堆上分配。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“<strong>GC堆</strong>”。<br>
从内存回收的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆还可以细分为<strong>新生代</strong>、<strong>老年代</strong>和<strong>永久代</strong>，新生代又包括<code>Eden</code>空间、<code>From Survivor</code>空间和<code>To Survivor</code>空间。<br>
从内存分配的角度看，所有线程共享的Java堆中可以划分出多个线程私有的<strong>分配缓冲区</strong>（Thread Local Allocation Buffer, <strong>TLAB</strong>），以提升对象分配时的效率。<br>
根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的。<br>
如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p>
<h1 id="方法区">方法区</h1>
<p>方法区与Java堆一样是<strong>所有线程共享</strong>的内存区域，用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量和即时编译器编译后的代码缓存</strong>等数据。虽然《Java虚拟机规范》把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做<strong>Non-Heap（非堆）</strong>，目的是与Java堆区分开。<br>
《Java虚拟机规范》对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对<strong>常量池的回收</strong>和对<strong>类型的卸载</strong>，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。<br>
根据《Java虚拟机规范》的规定，当方法区无法满足新的内存分配需求时，将抛出<code>OutOfMemoryError</code>异常。<br>
运行时常量池是方法区的一部分，用于存放编译期生成的各种字面常量和符号引用，当常量池无法再申请到内存时会抛出<code>OutOfMemoryError</code>异常。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM内存分配]]></title>
        <id>https://MOMENTUMxx.github.io/post/jvm-nei-cun-fen-pei-yu-hui-shou-ce-lue/</id>
        <link href="https://MOMENTUMxx.github.io/post/jvm-nei-cun-fen-pei-yu-hui-shou-ce-lue/">
        </link>
        <updated>2020-10-08T07:18:33.000Z</updated>
        <summary type="html"><![CDATA[<p>Java技术体系的自动内存管理，最根本的目标是自动化的解决两个问题：自动给对象分配内存以及回收分配给对象的内存。关于回收内存，请见博文《Java垃圾收集》，本文主要来探讨一下关于给对象分配内存的那些事儿😉</p>
]]></summary>
        <content type="html"><![CDATA[<p>Java技术体系的自动内存管理，最根本的目标是自动化的解决两个问题：自动给对象分配内存以及回收分配给对象的内存。关于回收内存，请见博文《Java垃圾收集》，本文主要来探讨一下关于给对象分配内存的那些事儿😉</p>
<!-- more -->
<h1 id="jvm堆的结构分析新生代-老年代-永久代">JVM堆的结构分析（新生代、老年代、永久代）</h1>
<h2 id="堆分代的目的">堆分代的目的</h2>
<p>为了优化GC时的性能。如果没有分代，所有的对象都是在一起的，GC的时候我们要找到哪些对象没用，就需要对堆的所有区域进行扫描。而堆中的很多对象都是朝生夕死的，分代以后就可以把新创建的对象放到某一区域，当GC的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间来。</p>
<h2 id="年轻代中的gc">年轻代中的GC</h2>
<p>HotSpot虚拟机把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。<br>
因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是<strong>复制算法</strong>，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。<br>
在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1602142893177.png" alt="Minor GC示意图" loading="lazy"></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>i</mi><mi>n</mi><mi>o</mi><mi>r</mi><mi>G</mi><mi>C</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">意</mi><mi mathvariant="normal">图</mi></mrow><annotation encoding="application/x-tex">Minor GC示意图
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">意</span><span class="mord cjk_fallback">图</span></span></span></span></span></p>
<h2 id="有关年轻代的jvm参数">有关年轻代的JVM参数</h2>
<ul>
<li>-XX:NewSize和-XX:MaxNewSize<br>
用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。</li>
<li>-XX:SurvivorRatio<br>
用于设置Eden和其中一个Survivor的比值，这个值也比较重要。</li>
<li>-XX:+PrintTenuringDistribution<br>
用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。</li>
<li>-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold<br>
设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。</li>
</ul>
<h1 id="内存分配策略">内存分配策略</h1>
<h2 id="对象优先在eden分配">对象优先在Eden分配</h2>
<p>大多数情况下，对象在新生代Eden中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。<br>
<strong>Minor GC和Full GC的区别：</strong><br>
- 新生代GC (Minor GC)：指发生在新生代的垃圾收集动作，因为Java时象大多都具备朝生夕灭的特性，所以 Minor GC非常倾繁，一般回收速度也比较快。<br>
- 老年代GC (Major GC / Full GC )：指发生在老年代的GC，出现了 Major GC，经常会伴随至少一次的 Minor GC，Major GC的速度一般会比Minor GC慢10倍以上。</p>
<h2 id="大对象直接进入老年代">大对象直接进入老年代</h2>
<p>大对象就是指需要大量连续内存空间的Java对象，最典型的大对象就是很长的字符串，或者元素数量很庞大的数组。我们在写程序时要避免“朝生夕死”的“短命大对象”，原因是在分配空间时它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着高额的内存复制开销。虚拟机提供了一个-XX: PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法收集内存）。</p>
<h2 id="长期存活的对象将进入老年代">长期存活的对象将进入老年代</h2>
<p>HotSpot虚拟机采用分代收集的思想来管理虚拟机内存。虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并且经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将其年龄设定为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就会被晋升到老年代。对象晋升到老年代的年龄阈值可以通过-XX:MaxTenuringThreshold设置。</p>
<h2 id="动态对象年龄判定">动态对象年龄判定</h2>
<p>虚拟并不是永远都要求对象年龄必须达到MaxTenuringThreshold才能晋升为老年代的，如果在Survivor的空间相同年龄的所有对象大小总和大于Survivor空间的一半时，年龄大于或者等于该年龄的对象直接进入老年代，无需要等到MaxTenuringThreshold中要求的年龄。</p>
<h2 id="空间分配担保">空间分配担保</h2>
<p>在发生Minor GC之前，虚拟机会先检查老年代可用的连续空间是否大于新生代所有对象总空间，如果条件成立，那么这次Minor GC就可以保证安全。否则虚拟机会查看-XX:HandlePromotionFailure参数的设置值是否允许担保失败；如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX:HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。<br>
解释一下这里的“冒险”是指什么，<strong>新生代使用复制收集算法</strong>，但为了提高内存利用率，只用一个Survivor空间来作为轮换备份，当大量对象在Minor GC后都存活下来时（最极端情况是所有对象都存活），Survivor空间无法容纳所有活下来的对象，这时候需要老年代进行分配担保，来减轻Survivor的压力。担保的前提是老年代有足够的空间，但本次回收中一共有多少对象会存活下来是无法提前知道的，只能用历次晋升到老年代对象的平均大小作为经验值，这其实是一种赌概率的方法，如果出现了担保失败，就只好老老实实的发起一次Full GC。虽然有失败的风险，但通常还是会将-XX:HandlePromotionFailure开关打开，避免Full GC过于频繁。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搭建你的专属博客]]></title>
        <id>https://MOMENTUMxx.github.io/post/ge-ren-bo-ke-de-da-jian-ji-yu-dao-de-yi-xie-wen-ti/</id>
        <link href="https://MOMENTUMxx.github.io/post/ge-ren-bo-ke-de-da-jian-ji-yu-dao-de-yi-xie-wen-ti/">
        </link>
        <updated>2020-08-13T07:45:15.000Z</updated>
        <summary type="html"><![CDATA[<p>最近搭建了一个简易的个人博客，正好有时间将这个过程大致记录下来，方便自己日后的查看，也希望能帮助到有需要的人😏😏<br>
关键词：github pages，freenom，cloudflare，gridea</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近搭建了一个简易的个人博客，正好有时间将这个过程大致记录下来，方便自己日后的查看，也希望能帮助到有需要的人😏😏<br>
关键词：github pages，freenom，cloudflare，gridea</p>
<!-- more -->
<h1 id="搭建github-pages">搭建GitHub Pages</h1>
<p>GitHub Pages是一个轻量级的个人博客服务，具有以下的一些优势:</p>
<ul>
<li>完全免费</li>
<li>无须购买云服务进行搭建，只需按步骤一步步操作</li>
<li>支持的功能丰富，可以绑定域名、使用免费的HTTPS、DIY网站的主题、使用插件...</li>
<li>GitHub会替我们处理系统维护、文件存储一类的事情，我们只需要专注于文章的创作<br>
首先需要一个GitHub的账号，在个人主页中创建一个新的Repository<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597306995353.png" alt="" loading="lazy"><br>
在 Repository name 的位置填写域名，格式：用户名.github.io<br>
创建成功后点击右上角Settings,找到 GitHub Pages 选项，选择一个 GitHub 官方提供的主题<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597307223084.jpg" alt="" loading="lazy"><br>
随意选择一个主题后GitHub Pages 就会自动帮你生成好网站，在跳转的界面点击 Commit changes 按钮，网站就可以访问了<br>
在浏览器输入你的项目名称，也就是 用户名.github.io 即可看到你个人网站的主页啦~<br>
接下来我们还需要配置自定义域名和开启HTTPS功能，稍后会说到如何申请一个免费的域名，将申请到的域名填写在Custom domain一栏，然后勾选Enforce HTTPS即可<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597313250998.png" alt="" loading="lazy"></li>
</ul>
<h1 id="注册freenom免费域名">注册freenom免费域名</h1>
<p>个人博客的搭建少不了用到一枚域名，虽然现在的域名很便宜，但免费的还是香啊~<br>
我们熟知的免费域名有.tk，.ml，.cf等。.tk是南太平洋岛国托克劳的顶级域名，.ml是马里的顶级域名，.cf是中非共和国的域名。以前这些免费域名都是分开注册的，后来都被托管到了freenom，更加方便大家的注册。<br>
话不多说，直接开搞！<br>
首先进入freenom的<a href="http://www.freenom.com">官网</a>，输入一个你喜欢的域名然后点击检查可用性<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597308712913.png" alt="" loading="lazy"><br>
选择一个点击现在获取，然后点击右上角完成<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597308969452.png" alt="" loading="lazy"><br>
选择最长有效期十二个月有效，然后点击continue；需要注意，务必在域名即将到期前，手动续期域名，否则你可能会失去你拥有的域名。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597309052877.png" alt="" loading="lazy"><br>
接下来需要进行邮件验证或是登录谷歌账号，我选择登录谷歌账户（不知道为什么每隔一会儿我的登录信息就会失效要求重新登陆，难道是人品不好？？）<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597309216978.png" alt="" loading="lazy"><br>
登陆以后先别着急，有一个地方需要注意，我们需要处于科学上网的环境，并且地址需要在<strong>美国</strong>，一定要在美国，否则会出问题。所以接下来我们修改自己的个人信息<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597309728208.png" alt="" loading="lazy"><br>
<img src="https://MOMENTUMxx.github.io/post-images/1597309734629.png" alt="" loading="lazy"><br>
地址这里我只是做一个演示，重点是要在美国<br>
更改成功以后就可以进到购物车愉快的下单啦<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597310001604.png" alt="" loading="lazy"><br>
<img src="https://MOMENTUMxx.github.io/post-images/1597310006316.png" alt="" loading="lazy"><br>
至此在freenom申请一个免费的域名就基本完成了，还留下一点点工作，就是配置DNS域名服务器，将其更改成CloudFlare提供给我们的地址（稍后会说到如何获取）<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597323177509.png" alt="" loading="lazy"><br>
<img src="https://MOMENTUMxx.github.io/post-images/1597312707981.png" alt="" loading="lazy"><br>
<img src="https://MOMENTUMxx.github.io/post-images/1597312713919.png" alt="" loading="lazy"><br>
<img src="https://MOMENTUMxx.github.io/post-images/1597312719261.png" alt="" loading="lazy"></p>
<h1 id="给个人博客套上cdn加速">给个人博客套上CDN加速</h1>
<p>CDN的全称是Content Delivery Network，即内容分发网络。简单来说就是套上CDN之后会隐藏你的真实IP，访客会通过访问就近CDN服务器再访问你的网站，能保证网站访问速度，降低延迟，能抵御一定的攻击。通俗一点来说就是网络加速器，但是目前国内的CDN加速服务都是收费的，包括腾讯云、阿里云都提供相关服务。而且国内需要备案。所以我们选择Cloudflare（也叫cf）<br>
还是先来到<a href="https://www.cloudflare.com/">官网</a>，注册并登录<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597310725765.png" alt="" loading="lazy"><br>
选择添加站点到下一步，这里的站点输入我们刚才在freenom免费申请的域名<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597310732345.png" alt="" loading="lazy"><br>
之后会要求我们选择一个计划，我们选择一个免费的即可，跟着提示信息走就可以了<br>
有两个地方是需要我们来关注的：</p>
<ol>
<li>我们需要添加DNS记录：<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597311520674.png" alt="" loading="lazy"><br>
类型这里可以根据需求进行选择，如你想要解析到一个IPV4地址，则选择&quot;A&quot;;如你想要解析到一个IPV6地址，则选择&quot;AAAA&quot;;如你需要将域名指向另一个域名，再由另一个域名提供ip地址，则选择&quot;CNAME&quot;等等诸如此类，具体可查看类型介绍<br>
因为我们的博客托管到GitHub Pages上，所以这里的类型选择CNAME，名称填写在freenom申请到的域名，目标填写在GitHub Pages上的项目地址也就是 用户名.github.io，TTL选择自动即可，然后将后面的云朵点亮表示通过通过 Cloudflare 代理流量</li>
<li>另一个需要关注的地方就是Cloudflare为我们提供的域名服务器，把它们填写在之前提过的在freenom配置DNS的位置就可以了，同时修改成功后会收到dns服务器修改成功的邮件<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597312287482.png" alt="" loading="lazy"><br>
CloudFlare有一些好用的功能，比如：</li>
</ol>
<ul>
<li>免费且快速的DNS服务</li>
<li>免费的SSL证书</li>
<li>限制某些地区的IP访问等操作</li>
<li>防止网络攻击</li>
<li>网站缓存和加速</li>
<li>一个cloudflare账户免费绑定多个网站<br>
更加详细的使用教程可以参考<a href="https://www.jianshu.com/p/1e73c2d66ac8">这里</a></li>
</ul>
<h1 id="gridea-更方便的管理github-pages">Gridea--更方便的管理GitHub Pages</h1>
<p>点击<a href="https://gridea.dev/">这里</a>进入官网下载Gridea的客户端，虽然搭建博客的过程可能让你觉得简单，但是管理和推送文章却相对麻烦不少，在<a href="https://pages.github.com/">官方教程</a>里，我们需要经历繁琐的步骤才能发布一篇文章和修改个人空间界面。相较于官方提供的 GitHub Desktop 和在终端使用 Git 的方法管理 Github Pages，Gridea 这款工具则更为的便捷和优雅，它能让作为创作者的你更专注于写作<br>
接下来我们说一下Gridea的配置和基本使用方法<br>
首先是基本配置<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597313686244.png" alt="" loading="lazy"><br>
还是比较直观的，平台选择GitHub Pages，域名选择 https:// 然后填写 用户名.github.io，令牌在<a href="https://github.com/settings/tokens">这里</a>获取，CNAME填写我们在freenom申请到的域名<br>
这里有个安全上的小 Tip，我们在创建 Personal access tokens 的时候，只需要赋予 repo 的权限即可，这样最大程度减少 Token 出现泄漏后可能造成的安全风险。<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597313962084.png" alt="" loading="lazy"><br>
配置好后可以点击“检测远程连接”按钮进行测试<br>
Gridea可以让你选择使用不同的主题来满足你的个性化需求，在<a href="https://gridea.dev/themes/">这里</a>可以看到官网上的主题市场，快去选择一款酷炫的主题并自定义它的配置吧~</p>
<h1 id="可能遇到的问题及解决方法">可能遇到的问题及解决方法</h1>
<ol>
<li>使用CloudFlare后提示“将您重定向的次数过多”<br>
原因：如果服务器设置了HTTP重定向到HTTPS，由于CloudFlare CDN默认SSL设置为“Flexible”模式（HTTP请求），这时服务器对于CloudFlare的响应会被加密，从而访问失败并不断重复发送相同请求。访问网站会提示“将您重定向的次数过多”或“ERR_TOO_MANY_REDIRECTS”错误，按提示清除浏览器Cookie也没用<br>
解决方法：只需调整CloudFlare后台Crypto页面里的SSL设置，改为 Full 或 Full (strict) 模式（前者不验证服务器证书，后者则会）<br>
<img src="https://MOMENTUMxx.github.io/post-images/1597322269245.png" alt="" loading="lazy"></li>
<li>打开网站后css的样式不对，F12的错误信息为：Mixed Content: The page at 'xxx' was loaded over HTTPS, but requested an insecure resource 'xxx'.<br>
原因：HTTPS页面里动态的引入HTTP资源，比如引入一个js文件，会被直接block掉的.在HTTPS页面里通过AJAX的方式请求HTTP资源，也会被直接block掉的。<br>
解决方法：页面的head中加入：<br>
<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt;</code><br>
意思是自动将http的不安全请求升级为https</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://MOMENTUMxx.github.io/post/hello-gridea/</id>
        <link href="https://MOMENTUMxx.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>